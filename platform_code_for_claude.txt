================================================================================
AI-POWERED TRADING ANALYSIS PLATFORM - COMPLETE CODE FOR REVIEW
================================================================================

Project: AI Trading Platform with ML predictions, automated monitoring, and divergence timing intelligence
Date: November 14, 2025
Purpose: Code review by Claude AI for architecture, performance, and optimization suggestions

================================================================================
TABLE OF CONTENTS
================================================================================

1. app.py - Main Streamlit UI (1486 lines)
2. position_monitor.py - Position monitoring with 3-tier priority (514 lines)
3. technical_indicators.py - 12+ indicators with trend context (508 lines)
4. ml_engine.py - Dual ML models (Random Forest + XGBoost) (1128 lines)
5. whale_tracker.py - Whale detection and smart money analysis (153 lines)
6. database.py - SQLAlchemy models and auto-migration (206 lines)
7. scheduler.py - Background 15-min monitoring (80 lines)
8. api_integrations.py - Unified API client (239 lines)
9. divergence_logger.py - Divergence detection logging (117 lines)
10. divergence_resolver.py - Auto-resolve divergences (133 lines)
11. divergence_analytics.py - Timing statistics calculation (245 lines)

================================================================================
KEY FEATURES TO REVIEW
================================================================================

1. Triple-Layer Alert System:
   - Global banner on ALL tabs for HIGH severity alerts
   - Auto-check when viewing Position Tracker
   - 15-minute background scheduler backup

2. Priority-Based Risk Management:
   - HIGH alerts (approaching SL, OBV flip) ‚Üí EXIT immediately
   - SL/TP triggers ‚Üí Override all indicators
   - Indicator signals ‚Üí Last priority

3. Divergence Timing Intelligence:
   - Tracks detection ‚Üí resolution lifecycle
   - Speed classification (FAST/ACTIONABLE/SLOW)
   - Success rate tracking per indicator/timeframe

4. Self-Improving ML:
   - Dual loop: Learns from closed trades
   - Dynamic indicator weighting
   - Auto-invalidates outdated models

5. Custom Symbol Search:
   - Supports ANY trading pair
   - Auto-maps custom symbols to forex API

================================================================================
REVIEW QUESTIONS FOR CLAUDE
================================================================================

1. Architecture: Is modular separation clean? Any coupling issues?
2. Performance: Race conditions in scheduler + auto-check?
3. ML Quality: Feature engineering solid? Model choice appropriate?
4. Risk Logic: 3-tier priority system - any edge cases?
5. Database: Auto-migration safe? JSON columns performance impact?
6. Code Quality: Type hints? Error handling? Testing gaps?
7. Scalability: Can handle 50+ positions? Query optimization?
8. Security: API key management? SQL injection? Input validation?

================================================================================
1. app.py - MAIN STREAMLIT UI
================================================================================

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import os
import pytz

from database import init_db, get_session, Trade, ActivePosition, ModelPerformance
from api_integrations import get_market_data_unified, get_current_price, OKXClient
from technical_indicators import TechnicalIndicators, calculate_support_resistance
from whale_tracker import WhaleTracker
from ml_engine import MLTradingEngine
from position_monitor import PositionMonitor
from scheduler import get_scheduler
from divergence_logger import log_divergences_from_context
from divergence_analytics import get_divergence_timing_info

st.set_page_config(
    page_title="AI Trading Platform",
    page_icon="üìà",
    layout="wide",
    initial_sidebar_state="expanded"
)

@st.cache_resource
def initialize_database():
    init_db()

@st.cache_resource
def start_background_scheduler():
    scheduler = get_scheduler()
    scheduler.start()
    return scheduler

initialize_database()
start_background_scheduler()

CRYPTO_PAIRS = [
    'BTC/USD', 'ETH/USD', 'XRP/USD', 'SOL/USD', 'ADA/USD',
    'DOGE/USD', 'MATIC/USD', 'DOT/USD', 'AVAX/USD', 'LINK/USD'
]

FOREX_PAIRS = [
    'EUR/USD', 'GBP/USD', 'USD/JPY', 'USD/CHF', 'AUD/USD',
    'USD/CAD', 'NZD/USD'
]

METALS = [
    'XAU/USD', 'XAG/USD', 'XPT/USD', 'XPD/USD'
]

# Riyadh Timezone (GMT+3)
RIYADH_TZ = pytz.timezone('Asia/Riyadh')

def format_price(price):
    """
    Smart price formatting based on value:
    - Prices < $1: 5 decimals (e.g., $0.55495)
    - Prices $1-$10: 4 decimals (e.g., $5.5549)
    - Prices >= $10: 2 decimals (e.g., $45,234.50)
    """
    if price is None:
        return "N/A"
    
    if price < 1:
        return f"${price:,.5f}"
    elif price < 10:
        return f"${price:,.4f}"
    else:
        return f"${price:,.2f}"

def check_global_alerts():
    """Check all active positions for HIGH severity alerts"""
    try:
        monitor = PositionMonitor()
        results = monitor.check_active_positions()
        
        high_alerts = []
        for result in results:
            if result.get('status') == 'success' and result.get('monitoring_alerts'):
                for alert in result['monitoring_alerts']:
                    if alert.get('severity') == 'HIGH':
                        high_alerts.append({
                            'symbol': result['symbol'],
                            'message': alert['message'],
                            'recommendation': result['recommendation']
                        })
        
        return high_alerts
    except Exception as e:
        return []

def convert_to_riyadh_time(utc_dt):
    """Convert UTC datetime to Riyadh time (GMT+3)"""
    if utc_dt is None:
        return None
    
    # If datetime is naive (no timezone), assume it's UTC
    if utc_dt.tzinfo is None:
        utc_dt = pytz.utc.localize(utc_dt)
    
    # Convert to Riyadh time
    riyadh_dt = utc_dt.astimezone(RIYADH_TZ)
    return riyadh_dt

def check_api_keys():
    twelve_data_key = os.getenv('TWELVE_DATA_API_KEY')
    okx_key = os.getenv('OKX_API_KEY')
    
    if not twelve_data_key:
        st.error("‚ö†Ô∏è TWELVE_DATA_API_KEY is required for the platform to work!")
        with st.expander("üîë How to add your Twelve Data API key"):
            st.write("""
            **Twelve Data provides ALL market data (Crypto, Forex, Metals)**
            
            1. Sign up at https://twelvedata.com/ (FREE account)
            2. Copy your API key from the dashboard
            3. In Replit, click the üîí Secrets tab (lock icon on left sidebar)
            4. Click "New Secret"
            5. Key: `TWELVE_DATA_API_KEY`
            6. Value: [paste your API key]
            7. Refresh this page
            
            **Free tier includes:**
            - 800 API calls per day
            - All crypto pairs (BTC, ETH, etc.)
            - All forex pairs (EUR/USD, GBP/USD, etc.)
            - Precious metals (Gold, Silver, etc.)
            """)
        return False
    
    st.success("‚úÖ Twelve Data API key configured - All markets available!")
    if not okx_key:
        st.info("üí° Optional: Add OKX_API_KEY for orderbook data and whale tracking on crypto")
    
    return True

def plot_candlestick_chart(df, indicators_df, symbol, support_levels, resistance_levels):
    fig = make_subplots(
        rows=4, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.03,
        row_heights=[0.5, 0.15, 0.15, 0.15],
        subplot_titles=(f'{symbol} Price Action', 'RSI', 'MACD', 'Volume')
    )
    
    fig.add_trace(
        go.Candlestick(
            x=df['timestamp'],
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close'],
            name='Price'
        ),
        row=1, col=1
    )
    
    if 'SMA_20' in indicators_df.columns:
        fig.add_trace(
            go.Scatter(x=indicators_df['timestamp'], y=indicators_df['SMA_20'],
                      name='SMA 20', line=dict(color='orange', width=1)),
            row=1, col=1
        )
    
    if 'SMA_50' in indicators_df.columns:
        fig.add_trace(
            go.Scatter(x=indicators_df['timestamp'], y=indicators_df['SMA_50'],
                      name='SMA 50', line=dict(color='blue', width=1)),
            row=1, col=1
        )
    
    if 'EMA_12' in indicators_df.columns:
        fig.add_trace(
            go.Scatter(x=indicators_df['timestamp'], y=indicators_df['EMA_12'],
                      name='EMA 12', line=dict(color='green', width=1, dash='dash')),
            row=1, col=1
        )
    
    if 'BB_upper' in indicators_df.columns:
        fig.add_trace(
            go.Scatter(x=indicators_df['timestamp'], y=indicators_df['BB_upper'],
                      name='BB Upper', line=dict(color='gray', width=1, dash='dot')),
            row=1, col=1
        )
        fig.add_trace(
            go.Scatter(x=indicators_df['timestamp'], y=indicators_df['BB_lower'],
                      name='BB Lower', line=dict(color='gray', width=1, dash='dot'),
                      fill='tonexty', fillcolor='rgba(128,128,128,0.1)'),
            row=1, col=1
        )
    
    for level in support_levels:
        fig.add_hline(y=level, line_dash="dash", line_color="green", 
                     annotation_text=f"S: {level}", row=1, col=1)
    
    for level in resistance_levels:
        fig.add_hline(y=level, line_dash="dash", line_color="red",
                     annotation_text=f"R: {level}", row=1, col=1)
    
    if 'RSI' in indicators_df.columns:
        fig.add_trace(
            go.Scatter(x=indicators_df['timestamp'], y=indicators_df['RSI'],
                      name='RSI', line=dict(color='purple', width=2)),
            row=2, col=1
        )
        fig.add_hline(y=70, line_dash="dash", line_color="red", row=2, col=1)
        fig.add_hline(y=30, line_dash="dash", line_color="green", row=2, col=1)
    
    if 'MACD' in indicators_df.columns:
        fig.add_trace(
            go.Scatter(x=indicators_df['timestamp'], y=indicators_df['MACD'],
                      name='MACD', line=dict(color='blue', width=2)),
            row=3, col=1
        )
    if 'MACD_signal' in indicators_df.columns:
        fig.add_trace(
            go.Scatter(x=indicators_df['timestamp'], y=indicators_df['MACD_signal'],
                      name='Signal', line=dict(color='orange', width=2)),
            row=3, col=1
        )
    if 'MACD_hist' in indicators_df.columns:
        colors = ['green' if val >= 0 else 'red' for val in indicators_df['MACD_hist']]
        fig.add_trace(
            go.Bar(x=indicators_df['timestamp'], y=indicators_df['MACD_hist'],
                  name='Histogram', marker_color=colors),
            row=3, col=1
        )
    
    fig.add_trace(
        go.Bar(x=df['timestamp'], y=df['volume'], name='Volume',
              marker_color='lightblue'),
        row=4, col=1
    )
    
    fig.update_layout(
        height=1000,
        showlegend=True,
        xaxis_rangeslider_visible=False,
        hovermode='x unified'
    )
    
    return fig

st.title("üìà AI-Powered Trading Analysis Platform")
st.markdown("**Real-time Market Analysis | ML Predictions | Position Monitoring**")

check_api_keys()

menu = st.sidebar.selectbox(
    "Navigation",
    ["Market Analysis", "Trading Signals", "Position Tracker", "Risk Calculator", "Performance Analytics", "Model Training"]
)

# GLOBAL ALERT BANNER - Shows HIGH severity warnings on all tabs
global_alerts = check_global_alerts()
if global_alerts:
    for alert in global_alerts:
        st.error(f"üö® **CRITICAL ALERT: {alert['symbol']}** - {alert['message']}")
        if menu != "Position Tracker":
            st.info("üëâ Go to **Position Tracker** tab to view details and take action")
    st.divider()

if menu == "Market Analysis":
    st.header("üìä Market Analysis Dashboard")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        market_type = st.selectbox("Market Type", ["crypto", "forex", "metals", "custom"])
    
    with col2:
        if market_type == "crypto":
            symbol = st.selectbox("Select Pair", CRYPTO_PAIRS)
        elif market_type == "forex":
            symbol = st.selectbox("Select Pair", FOREX_PAIRS)
        elif market_type == "metals":
            symbol = st.selectbox("Select Metal", METALS)
        else:  # custom
            symbol = st.text_input("üîç Enter Symbol (e.g., AAPL/USD, TSLA/USD, LTC/USD)", placeholder="BTC/USD").upper()
    
    with col3:
        timeframe = st.selectbox("Timeframe", ["5m", "15m", "30m", "1H", "4H", "1D"])
    
    if st.button("Analyze Market", type="primary"):
        if not symbol or symbol.strip() == "":
            st.error("‚ùå Please enter a trading pair symbol")
            st.stop()
        
        # Map 'custom' to 'forex' for API compatibility (Twelve Data treats most symbols as forex pairs)
        api_market_type = "forex" if market_type == "custom" else market_type
        
        with st.spinner("Fetching market data..."):
            try:
                df = get_market_data_unified(symbol, api_market_type, timeframe, 100)
                
                if df is None:
                    st.error(f"‚ùå Failed to fetch data for {symbol} on {timeframe} timeframe. API may have returned an error.")
                    st.info("üí° Try a different timeframe or check if your API key is valid")
                    st.stop()
                    
                if len(df) == 0:
                    st.error(f"‚ùå No data available for {symbol}")
                    st.stop()
            except Exception as e:
                st.error(f"‚ùå Error fetching data: {str(e)}")
                st.stop()
            
            if df is not None and len(df) > 0:
                tech = TechnicalIndicators(df)
                indicators_df = tech.calculate_all_indicators()
                latest_indicators = tech.get_latest_indicators()
                signals = tech.get_trend_signals()
                
                # Get historical trend context for duration/slope/divergence analysis
                trend_context = tech.get_trend_context(symbol, api_market_type)
                latest_indicators['trend_context'] = trend_context
                
                support_levels, resistance_levels = calculate_support_resistance(indicators_df)
                
                st.success(f"‚úÖ Analysis complete for {symbol}")
                
                col1, col2, col3, col4, col5 = st.columns(5)
                current_price = latest_indicators.get('current_price', 0)
                
                with col1:
                    st.metric("Current Price", format_price(current_price))
                with col2:
                    rsi = latest_indicators.get('RSI')
                    st.metric("RSI", f"{rsi:.1f}" if rsi else "N/A")
                with col3:
                    adx = latest_indicators.get('ADX')
                    st.metric("ADX", f"{adx:.1f}" if adx else "N/A")
                with col4:
                    mfi = latest_indicators.get('MFI')
                    st.metric("MFI", f"{mfi:.1f}" if mfi else "N/A")
                with col5:
                    obv = latest_indicators.get('OBV')
                    if obv is not None:
                        obv_formatted = f"{obv:,.0f}" if abs(obv) > 1000 else f"{obv:.2f}"
                        st.metric("OBV", obv_formatted)
                    else:
                        st.metric("OBV", "N/A")
                
                st.plotly_chart(
                    plot_candlestick_chart(df, indicators_df, symbol, support_levels, resistance_levels),
                    use_container_width=True
                )
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.subheader("Technical Signals")
                    for indicator, signal in signals.items():
                        color = "üü¢" if signal in ['bullish', 'oversold', 'strong_uptrend'] else "üî¥" if signal in ['bearish', 'overbought', 'strong_downtrend'] else "üü°"
                        
                        # Show raw values for ADX for transparency
                        if indicator == 'ADX':
                            adx_val = latest_indicators.get('ADX', 0)
                            di_plus = latest_indicators.get('DI_plus', 0)
                            di_minus = latest_indicators.get('DI_minus', 0)
                            st.write(f"{color} **{indicator}**: {signal}")
                            st.caption(f"   ADX: {adx_val:.1f} | +DI: {di_plus:.1f} | -DI: {di_minus:.1f}")
                        else:
                            st.write(f"{color} **{indicator}**: {signal}")
                    
                    st.divider()
                    st.subheader("üß† Smart Money (OBV)")
                    obv_ctx = trend_context.get('OBV', {})
                    obv_slope = obv_ctx.get('slope', 0.0)
                    obv_divergence = obv_ctx.get('divergence', 'none')
                    
                    if obv_divergence == 'bullish':
                        st.write("üü¢ **Bullish Divergence** - Smart money accumulating")
                        st.caption(f"   Slope: {obv_slope:+.2f} (Price down, volume up)")
                        
                        # Show timing intelligence
                        timing_info = get_divergence_timing_info('OBV', timeframe, 'bullish')
                        if timing_info:
                            st.info(f"‚è±Ô∏è **Timing Intel**: Typically resolves in {timing_info['avg_candles']:.1f} candles ({timing_info['avg_hours']:.1f}hrs) | Success: {timing_info['success_rate']:.0f}% | {timing_info['recommendation']}")
                    elif obv_divergence == 'bearish':
                        st.write("üî¥ **Bearish Divergence** - Smart money distributing")
                        st.caption(f"   Slope: {obv_slope:+.2f} (Price up, volume down)")
                        
                        # Show timing intelligence
                        timing_info = get_divergence_timing_info('OBV', timeframe, 'bearish')
                        if timing_info:
                            speed_emoji = "‚ö†Ô∏è" if timing_info['speed_class'] == 'fast' else "‚úÖ" if timing_info['speed_class'] == 'actionable' else "‚è±Ô∏è"
                            st.info(f"{speed_emoji} **Timing Intel**: Typically resolves in {timing_info['avg_candles']:.1f} candles ({timing_info['avg_hours']:.1f}hrs) | Success: {timing_info['success_rate']:.0f}% | {timing_info['recommendation']}")
                    else:
                        slope_direction = "Rising" if obv_slope > 0.5 else "Falling" if obv_slope < -0.5 else "Flat"
                        slope_color = "üü¢" if obv_slope > 0.5 else "üî¥" if obv_slope < -0.5 else "üü°"
                        st.write(f"{slope_color} **{slope_direction}** - No divergence")
                        st.caption(f"   Slope: {obv_slope:+.2f}")
                
                with col2:
                    st.subheader("Candlestick Patterns")
                    patterns = tech.detect_candlestick_patterns()
                    if patterns:
                        for pattern_name, signal in patterns.items():
                            if signal == 'bullish':
                                st.write(f"üü¢ **{pattern_name.replace('_', ' ')}** (Bullish)")
                            elif signal == 'bearish':
                                st.write(f"üî¥ **{pattern_name.replace('_', ' ')}** (Bearish)")
                            else:
                                st.write(f"üü° **{pattern_name.replace('_', ' ')}** (Neutral)")
                    else:
                        st.info("No patterns detected")
                
                with col3:
                    st.subheader("Support & Resistance")
                    st.write("**Resistance Levels:**")
                    for r in resistance_levels:
                        st.write(f"üî¥ {format_price(r)}")
                    st.write("**Support Levels:**")
                    for s in support_levels:
                        st.write(f"üü¢ {format_price(s)}")
                
                if market_type == "crypto":
                    st.subheader("üêã Whale & Smart Money Analysis")
                    okx_client = OKXClient(api_key=os.getenv('OKX_API_KEY'))
                    orderbook = okx_client.get_orderbook(symbol)
                    
                    whale_tracker = WhaleTracker(indicators_df, orderbook)
                    whale_movements = whale_tracker.detect_whale_movements()
                    smart_money = whale_tracker.detect_smart_money()
                    volume_profile = whale_tracker.get_volume_profile()
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        if whale_movements:
                            st.write("**Recent Whale Activity:**")
                            for movement in whale_movements[:5]:
                                st.write(f"{movement['transaction_type']} - Impact Score: {movement['impact_score']:.1f}")
                        else:
                            st.info("No significant whale activity detected")
                    
                    with col2:
                        if smart_money:
                            st.write("**Smart Money Signals:**")
                            for signal in smart_money:
                                st.write(f"‚Ä¢ {signal['description']} (Confidence: {signal['confidence']})")
                        else:
                            st.info("No smart money signals detected")
                    
                    if volume_profile:
                        st.write(f"**Volume Profile:** Current: {volume_profile['current_volume']:,.0f} | Avg: {volume_profile['average_volume']:,.0f} | {volume_profile['volume_vs_avg']:.0f}% of average")
                
                st.divider()
                st.subheader("ü§ñ AI Trading Recommendation")
                
                with st.spinner("Generating AI recommendation..."):
                    ml_engine = MLTradingEngine()
                    prediction = ml_engine.predict(latest_indicators)
                    
                    # Log divergences for timing intelligence (no logic change)
                    try:
                        if 'trend_context' in latest_indicators:
                            current_price = latest_indicators.get('close', 0)
                            log_divergences_from_context(symbol, timeframe, latest_indicators['trend_context'], current_price)
                    except Exception as e:
                        print(f"Divergence logging failed: {e}")
                    
                    st.session_state['last_prediction'] = prediction
                    st.session_state['last_symbol'] = symbol
                    st.session_state['last_market_type'] = api_market_type  # Store the API-compatible market type
                    st.session_state['last_timeframe'] = timeframe
                    st.session_state['last_indicators'] = latest_indicators
                    
                    if prediction['signal'] == 'LONG':
                        st.success(f"üìà **LONG** - Confidence: {prediction['confidence']:.1f}%")
                    elif prediction['signal'] == 'SHORT':
                        st.error(f"üìâ **SHORT** - Confidence: {prediction['confidence']:.1f}%")
                    else:
                        st.warning(f"‚è∏Ô∏è **HOLD** - Confidence: {prediction['confidence']:.1f}%")
                    
                    if prediction['entry_price'] is not None:
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric("Entry Price", format_price(prediction['entry_price']))
                        with col2:
                            st.metric("Stop Loss", format_price(prediction['stop_loss']))
                        with col3:
                            st.metric("Take Profit", format_price(prediction['take_profit']))
                    else:
                        st.info(prediction.get('recommendation', 'Insufficient data for prediction. Models not trained yet.'))
                    
                    if 'reasons' in prediction and prediction['reasons']:
                        st.write("**Why this recommendation?**")
                        for reason in prediction['reasons']:
                            st.write(f"‚Ä¢ {reason}")
                    
    
    if 'last_prediction' in st.session_state and st.session_state['last_prediction']:
        prediction = st.session_state['last_prediction']
        symbol = st.session_state.get('last_symbol', '')
        market_type = st.session_state.get('last_market_type', 'crypto')
        timeframe = st.session_state.get('last_timeframe', '1H')
        indicators = st.session_state.get('last_indicators', None)
        
        # Allow manual position tracking even when AI says HOLD
        st.divider()
        st.write("**üí° Want to track a position?**")
        
        col1, col2, col3 = st.columns([2, 2, 2])
        
        with col1:
            manual_direction = st.selectbox(
                "Trade Direction",
                ["LONG", "SHORT"],
                key="manual_direction",
                index=0 if prediction['signal'] == 'LONG' else (1 if prediction['signal'] == 'SHORT' else 0)
            )
        
        with col2:
            manual_entry = st.number_input(
                "Entry Price",
                min_value=0.0,
                value=float(prediction.get('entry_price', 0.0)) if prediction.get('entry_price') else 0.0,
                step=0.01,
                key="manual_entry_price"
            )
        
        with col3:
            trade_quantity = st.number_input(
                "Quantity (optional)", 
                min_value=0.0, 
                step=0.01,
                key="market_analysis_qty",
                help="Enter trade size"
            )
        
        col1, col2 = st.columns([2, 2])
        
        with col1:
            manual_sl = st.number_input(
                "Stop Loss",
                min_value=0.0,
                value=float(prediction.get('stop_loss', 0.0)) if prediction.get('stop_loss') else 0.0,
                step=0.01,
                key="manual_sl"
            )
        
        with col2:
            manual_tp = st.number_input(
                "Take Profit (optional)",
                min_value=0.0,
                value=float(prediction.get('take_profit', 0.0)) if prediction.get('take_profit') else 0.0,
                step=0.01,
                key="manual_tp"
            )
        
        if prediction['signal'] == 'HOLD':
            st.warning("‚ö†Ô∏è AI recommends HOLD - You're entering a manual position")
        
        if st.button("üìä Track This Position", type="primary", key="take_trade_market"):
            if manual_entry <= 0:
                st.error("‚ùå Please enter a valid entry price")
            else:
                monitor = PositionMonitor()
                result = monitor.add_position(
                    symbol,
                    market_type,
                    manual_direction,
                    manual_entry,
                    quantity=trade_quantity if trade_quantity > 0 else None,
                    stop_loss=manual_sl if manual_sl > 0 else None,
                    take_profit=manual_tp if manual_tp > 0 else None,
                    timeframe=timeframe,
                    indicators=indicators
                )
                
                if result['success']:
                    st.success(f"‚úÖ {result['message']}")
                    st.success(f"üéØ Position added: {symbol} {manual_direction} @ {format_price(manual_entry)}")
                    st.info("üìç Go to 'Position Tracker' to view and manage this position")
                    del st.session_state['last_prediction']
                    del st.session_state['last_symbol']
                    del st.session_state['last_market_type']
                    del st.session_state['last_timeframe']
                    if 'last_indicators' in st.session_state:
                        del st.session_state['last_indicators']
                    st.rerun()
                else:
                    st.error(f"‚ùå {result['message']}")

elif menu == "Trading Signals":
    st.header("üéØ Quick Signal Lookup")
    st.info("üí° Tip: Use 'Market Analysis' for full chart analysis + AI recommendation. This is for quick signal lookups only.")
    
    col1, col2 = st.columns(2)
    
    with col1:
        market_type = st.selectbox("Market Type", ["crypto", "forex", "metals", "custom"], key="signal_market")
    
    with col2:
        if market_type == "crypto":
            symbol = st.selectbox("Select Pair", CRYPTO_PAIRS, key="signal_symbol")
        elif market_type == "forex":
            symbol = st.selectbox("Select Pair", FOREX_PAIRS, key="signal_symbol")
        elif market_type == "metals":
            symbol = st.selectbox("Select Metal", METALS, key="signal_symbol")
        else:  # custom
            symbol = st.text_input("üîç Enter Symbol (e.g., AAPL/USD, TSLA/USD, LTC/USD)", placeholder="BTC/USD", key="signal_symbol_custom").upper()
    
    if st.button("Get AI Recommendation", type="primary"):
        if not symbol or symbol.strip() == "":
            st.error("‚ùå Please enter a trading pair symbol")
            st.stop()
        
        # Map 'custom' to 'forex' for API compatibility (Twelve Data treats most symbols as forex pairs)
        api_market_type = "forex" if market_type == "custom" else market_type
        
        with st.spinner("Analyzing with AI models..."):
            df = get_market_data_unified(symbol, api_market_type, '1H', 100)
            
            if df is not None and len(df) > 0:
                tech = TechnicalIndicators(df)
                tech.calculate_all_indicators()
                indicators = tech.get_latest_indicators()
                
                # Get historical trend context for duration/slope/divergence analysis
                trend_context = tech.get_trend_context(symbol, api_market_type)
                indicators['trend_context'] = trend_context
                
                ml_engine = MLTradingEngine()
                prediction = ml_engine.predict(indicators)
                
                st.session_state['last_signal_prediction'] = prediction
                st.session_state['last_signal_symbol'] = symbol
                st.session_state['last_signal_market_type'] = api_market_type  # Store the API-compatible market type
                st.session_state['last_signal_indicators'] = indicators
                
                st.subheader("AI Recommendation")
                
                signal_color = "üü¢" if prediction['signal'] == 'LONG' else "üî¥" if prediction['signal'] == 'SHORT' else "üü°"
                st.markdown(f"## {signal_color} {prediction['signal']}")
                st.markdown(f"**Confidence:** {prediction['confidence']}%")
                st.info(prediction['recommendation'])
                
                if prediction['entry_price']:
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Entry Price", format_price(prediction['entry_price']))
                    with col2:
                        st.metric("Stop Loss", format_price(prediction['stop_loss']))
                    with col3:
                        st.metric("Take Profit", format_price(prediction['take_profit']))
                
                with st.expander("Model Details"):
                    st.write(f"Random Forest Confidence: {prediction.get('rf_confidence', 0)}%")
                    st.write(f"XGBoost Confidence: {prediction.get('xgb_confidence', 0)}%")
                    st.write(f"Win Probability: {prediction.get('win_probability', 0)}%")
    
    if 'last_signal_prediction' in st.session_state and st.session_state['last_signal_prediction']:
        prediction = st.session_state['last_signal_prediction']
        symbol = st.session_state.get('last_signal_symbol', '')
        market_type = st.session_state.get('last_signal_market_type', 'crypto')
        signal_indicators = st.session_state.get('last_signal_indicators', None)
        
        # Allow manual position tracking even when AI says HOLD
        st.divider()
        st.write("**üí° Want to track a position?**")
        
        col1, col2, col3 = st.columns([2, 2, 2])
        
        with col1:
            manual_direction_signal = st.selectbox(
                "Trade Direction",
                ["LONG", "SHORT"],
                key="manual_direction_signal",
                index=0 if prediction['signal'] == 'LONG' else (1 if prediction['signal'] == 'SHORT' else 0)
            )
        
        with col2:
            manual_entry_signal = st.number_input(
                "Entry Price",
                min_value=0.0,
                value=float(prediction.get('entry_price', 0.0)) if prediction.get('entry_price') else 0.0,
                step=0.01,
                key="manual_entry_price_signal"
            )
        
        with col3:
            trade_quantity_signal = st.number_input(
                "Quantity (optional)", 
                min_value=0.0, 
                step=0.01,
                key="signal_qty",
                help="Enter trade size"
            )
        
        col1, col2 = st.columns([2, 2])
        
        with col1:
            manual_sl_signal = st.number_input(
                "Stop Loss",
                min_value=0.0,
                value=float(prediction.get('stop_loss', 0.0)) if prediction.get('stop_loss') else 0.0,
                step=0.01,
                key="manual_sl_signal"
            )
        
        with col2:
            manual_tp_signal = st.number_input(
                "Take Profit (optional)",
                min_value=0.0,
                value=float(prediction.get('take_profit', 0.0)) if prediction.get('take_profit') else 0.0,
                step=0.01,
                key="manual_tp_signal"
            )
        
        if prediction['signal'] == 'HOLD':
            st.warning("‚ö†Ô∏è AI recommends HOLD - You're entering a manual position")
        
        if st.button("üìä Track This Position", type="primary", key="take_trade_signal"):
            if manual_entry_signal <= 0:
                st.error("‚ùå Please enter a valid entry price")
            else:
                monitor = PositionMonitor()
                result = monitor.add_position(
                    symbol,
                    market_type,
                    manual_direction_signal,
                    manual_entry_signal,
                    quantity=trade_quantity_signal if trade_quantity_signal > 0 else None,
                    stop_loss=manual_sl_signal if manual_sl_signal > 0 else None,
                    take_profit=manual_tp_signal if manual_tp_signal > 0 else None,
                    indicators=signal_indicators
                )
                
                if result['success']:
                    st.success(f"‚úÖ {result['message']}")
                    st.success(f"üéØ Position added: {symbol} {manual_direction_signal} @ {format_price(manual_entry_signal)}")
                    st.info("üìç Go to 'Position Tracker' to view and manage this position")
                    del st.session_state['last_signal_prediction']
                    del st.session_state['last_signal_symbol']
                    del st.session_state['last_signal_market_type']
                    if 'last_signal_indicators' in st.session_state:
                        del st.session_state['last_signal_indicators']
                    st.rerun()
                else:
                        st.error(f"‚ùå {result['message']}")

elif menu == "Position Tracker":
    st.header("üìç Active Position Monitor")
    
    tab1, tab2, tab3 = st.tabs(["Active Positions", "Add Position", "Close Position"])
    
    with tab1:
        st.subheader("Your Active Positions")
        
        # AUTO-CHECK: Automatically check positions when tab loads
        if 'auto_checked_positions' not in st.session_state:
            st.session_state['auto_checked_positions'] = False
        
        if not st.session_state['auto_checked_positions']:
            monitor = PositionMonitor()
            with st.spinner("Auto-checking positions..."):
                monitor.check_active_positions()
                st.session_state['auto_checked_positions'] = True
        
        if st.button("üîÑ Check All Positions"):
            st.session_state['auto_checked_positions'] = False  # Reset to allow fresh check
            monitor = PositionMonitor()
            with st.spinner("Checking positions..."):
                results = monitor.check_active_positions()
                
                if results:
                    for result in results:
                        if result['status'] == 'success':
                            col1, col2, col3, col4 = st.columns(4)
                            
                            with col1:
                                st.write(f"**{result['symbol']}**")
                                st.write(f"Type: {result['trade_type']}")
                            
                            with col2:
                                st.metric("Entry", format_price(result['entry_price']))
                                st.metric("Current", format_price(result['current_price']))
                            
                            with col3:
                                pnl_color = "normal" if result['pnl_percentage'] >= 0 else "inverse"
                                st.metric("P&L", f"{result['pnl_percentage']:+.2f}%", delta_color=pnl_color)
                            
                            with col4:
                                rec_color = "üü¢" if result['recommendation'] == 'HOLD' else "üî¥"
                                st.write(f"{rec_color} **{result['recommendation']}**")
                                st.write(result['reason'])
                            
                            st.divider()
                else:
                    st.info("No active positions")
        
        session = get_session()
        positions = session.query(ActivePosition).filter(ActivePosition.is_active == True).all()
        session.close()
        
        if positions:
            for pos in positions:
                with st.expander(f"**{pos.symbol}** ({pos.trade_type}) - Entry: {format_price(pos.entry_price)}", expanded=False):
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.metric("Entry Price", format_price(pos.entry_price))
                        st.metric("Stop Loss", format_price(pos.stop_loss) if pos.stop_loss else "Not set")
                    with col2:
                        st.metric("Current Price", format_price(pos.current_price) if pos.current_price else "N/A")
                        st.metric("Take Profit", format_price(pos.take_profit) if pos.take_profit else "Not set")
                    with col3:
                        riyadh_time = convert_to_riyadh_time(pos.entry_time)
                        st.write(f"**Entry Time:** {riyadh_time.strftime('%Y-%m-%d %H:%M')} (Riyadh)")
                        st.write(f"**Quantity:** {pos.quantity}" if pos.quantity else "**Quantity:** Not set")
                    
                    # Show tight monitoring alerts
                    if pos.monitoring_alerts and isinstance(pos.monitoring_alerts, list) and len(pos.monitoring_alerts) > 0:
                        st.divider()
                        st.write("### üö® **Tight Monitoring Alerts**")
                        
                        for alert in pos.monitoring_alerts:
                            severity = alert.get('severity', 'MEDIUM')
                            alert_type = alert.get('type', '')
                            message = alert.get('message', '')
                            recommendation = alert.get('recommendation', '')
                            
                            if severity == 'HIGH':
                                st.error(f"{message}")
                                st.warning(f"**üí° Recommendation:** {recommendation}")
                            elif severity == 'MEDIUM':
                                st.warning(f"{message}")
                                st.info(f"**üí° Recommendation:** {recommendation}")
                    
                    # Show automatic monitoring recommendation
                    if pos.current_recommendation:
                        st.divider()
                        rec_color = "üü¢" if pos.current_recommendation == 'HOLD' else "üî¥"
                        st.write(f"### {rec_color} Auto-Monitor: **{pos.current_recommendation}**")
                        
                        if pos.last_check_time:
                            last_check_riyadh = convert_to_riyadh_time(pos.last_check_time)
                            st.caption(f"Last checked: {last_check_riyadh.strftime('%Y-%m-%d %H:%M:%S')} (Riyadh)")
                        
                        st.info("üí° Position is being monitored automatically every 15 minutes")
                    
                    st.divider()
                    st.write("**‚úèÔ∏è Adjust Entry Price**")
                    st.caption("Update entry price if it differs from your actual live trading platform entry")
                    
                    col_a, col_b = st.columns([2, 1])
                    
                    with col_a:
                        new_entry = st.number_input(
                            "New Entry Price",
                            min_value=0.0,
                            value=float(pos.entry_price),
                            step=0.01,
                            key=f"edit_entry_{pos.symbol}"
                        )
                    
                    with col_b:
                        st.write("")
                        st.write("")
                        if st.button("Update Entry", key=f"update_btn_{pos.symbol}"):
                            if new_entry != pos.entry_price:
                                monitor = PositionMonitor()
                                result = monitor.update_entry_price(pos.symbol, new_entry)
                                
                                if result['success']:
                                    st.success(f"‚úÖ {result['message']}")
                                    st.rerun()
                                else:
                                    st.error(f"‚ùå {result['message']}")
                            else:
                                st.info("No change - entry price is the same")
    
    with tab2:
        st.subheader("Add New Position")
        
        col1, col2 = st.columns(2)
        
        with col1:
            market_type = st.selectbox("Market Type", ["crypto", "forex", "metals", "custom"], key="add_market")
            if market_type == "crypto":
                symbol = st.selectbox("Pair", CRYPTO_PAIRS, key="add_symbol")
            elif market_type == "forex":
                symbol = st.selectbox("Pair", FOREX_PAIRS, key="add_symbol")
            elif market_type == "metals":
                symbol = st.selectbox("Metal", METALS, key="add_symbol")
            else:  # custom
                symbol = st.text_input("üîç Enter Symbol (e.g., AAPL/USD, TSLA/USD)", placeholder="BTC/USD", key="add_symbol_custom").upper()
            
            trade_type = st.selectbox("Trade Type", ["LONG", "SHORT"])
        
        with col2:
            entry_price = st.number_input("Entry Price", min_value=0.0, step=0.01)
            quantity = st.number_input("Quantity", min_value=0.0, step=0.01)
            stop_loss = st.number_input("Stop Loss (optional)", min_value=0.0, step=0.01)
            take_profit = st.number_input("Take Profit (optional)", min_value=0.0, step=0.01)
        
        if st.button("Add Position"):
            if not symbol or symbol.strip() == "":
                st.error("‚ùå Please enter a trading pair symbol")
                st.stop()
            
            # Map 'custom' to 'forex' for API compatibility
            api_market_type = "forex" if market_type == "custom" else market_type
            
            monitor = PositionMonitor()
            result = monitor.add_position(
                symbol, api_market_type, trade_type, entry_price,
                quantity if quantity > 0 else None,
                stop_loss if stop_loss > 0 else None,
                take_profit if take_profit > 0 else None
            )
            
            if result['success']:
                st.success(result['message'])
                st.rerun()
            else:
                st.error(result['message'])
    
    with tab3:
        st.subheader("Close Position")
        
        session = get_session()
        active_positions = session.query(ActivePosition).filter(ActivePosition.is_active == True).all()
        session.close()
        
        if active_positions:
            position_symbols = [f"{p.symbol} ({p.trade_type})" for p in active_positions]
            selected = st.selectbox("Select Position", position_symbols)
            
            selected_symbol = selected.split(" (")[0]
            selected_pos = next((p for p in active_positions if p.symbol == selected_symbol), None)
            
            if selected_pos:
                st.info(f"üìä Position: **{selected_pos.symbol}** | Entry: **{format_price(selected_pos.entry_price)}** | Current: **{format_price(selected_pos.current_price)}**" if selected_pos.current_price else f"üìä Position: **{selected_pos.symbol}** | Entry: **{format_price(selected_pos.entry_price)}**")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.write("**Exit Price**")
                if selected_pos and selected_pos.current_price:
                    st.caption(f"üí° Current market price: {format_price(selected_pos.current_price)}")
                    default_exit = float(selected_pos.current_price)
                else:
                    st.caption("üí° Enter your actual exit price from live platform")
                    default_exit = float(selected_pos.entry_price) if selected_pos else 0.0
                
                exit_price = st.number_input(
                    "Adjust exit price if needed", 
                    min_value=0.0, 
                    value=default_exit,
                    step=0.01, 
                    key="exit_price",
                    label_visibility="collapsed"
                )
                outcome = st.selectbox("Outcome", ["win", "loss"])
            
            with col2:
                exit_type = st.selectbox(
                    "Exit Type", 
                    ["Manual Exit", "TO Achieved (Stop Loss)", "TO Achieved (Take Profit)"],
                    help="Select how you exited: manually or if stop loss/take profit was hit"
                )
                
            notes = st.text_area(
                "Exit Notes (Optional)", 
                placeholder="Why did you exit? What did you learn from this trade?",
                help="Record your reasoning and observations for future learning"
            )
            
            if st.button("Close Position", type="primary"):
                symbol = selected.split(" (")[0]
                monitor = PositionMonitor()
                result = monitor.close_position(
                    symbol, 
                    exit_price, 
                    outcome,
                    exit_type=exit_type,
                    notes=notes if notes else None
                )
                
                if result['success']:
                    st.success(f"‚úÖ {result['message']}")
                    st.info("üìö System is learning from this trade to improve future predictions!")
                    st.rerun()
                else:
                    st.error(result['message'])
        else:
            st.info("No active positions to close")

elif menu == "Risk Calculator":
    st.header("üéØ Position Size Calculator")
    st.markdown("**Calculate the right position size based on your capital and risk tolerance**")
    
    st.info("üí° **Golden Rule**: Never risk more than 1-2% of your total capital on a single trade!")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Your Capital & Risk")
        total_capital = st.number_input(
            "Total Trading Capital ($)", 
            min_value=100.0, 
            value=10000.0,
            step=100.0,
            help="Your total available trading capital"
        )
        
        risk_percentage = st.slider(
            "Risk Per Trade (%)", 
            min_value=0.5, 
            max_value=5.0,
            value=1.0,
            step=0.25,
            help="Industry standard: 1-2%. Aggressive: 2-3%. Very risky: 3%+"
        )
        
        if risk_percentage <= 2.0:
            st.success(f"‚úÖ {risk_percentage}% is a safe risk level")
        elif risk_percentage <= 3.0:
            st.warning(f"‚ö†Ô∏è {risk_percentage}% is aggressive - be careful!")
        else:
            st.error(f"‚ùå {risk_percentage}% is very risky - you could lose your capital quickly!")
    
    with col2:
        st.subheader("Trade Details")
        
        trade_direction = st.selectbox(
            "Trade Direction",
            ["LONG", "SHORT"],
            help="LONG = Buy low, sell high. SHORT = Sell high, buy back low."
        )
        
        entry_price = st.number_input(
            "Entry Price ($)", 
            min_value=0.01, 
            value=65000.0,
            step=0.01,
            help="Your planned entry price for this trade"
        )
        
        if trade_direction == "LONG":
            stop_loss_price = st.number_input(
                "Stop Loss Price ($)", 
                min_value=0.01,
                value=64000.0,
                step=0.01,
                help="Stop loss BELOW entry (cut losses if price drops)"
            )
            
            take_profit_price = st.number_input(
                "Take Profit Price ($)", 
                min_value=0.01,
                value=68000.0,
                step=0.01,
                help="Take profit ABOVE entry (lock profits when price rises)"
            )
        else:  # SHORT
            stop_loss_price = st.number_input(
                "Stop Loss Price ($)", 
                min_value=0.01,
                value=66000.0,
                step=0.01,
                help="Stop loss ABOVE entry (cut losses if price rises)"
            )
            
            take_profit_price = st.number_input(
                "Take Profit Price ($)", 
                min_value=0.01,
                value=62000.0,
                step=0.01,
                help="Take profit BELOW entry (lock profits when price drops)"
            )
    
    st.divider()
    
    risk_amount = total_capital * (risk_percentage / 100)
    distance_to_stop = abs(entry_price - stop_loss_price)
    
    # Validate stop loss and take profit placement
    validation_errors = []
    
    if trade_direction == "LONG":
        if stop_loss_price >= entry_price:
            validation_errors.append("‚ùå **LONG trades**: Stop loss must be BELOW entry price")
        if take_profit_price <= entry_price:
            validation_errors.append("‚ùå **LONG trades**: Take profit must be ABOVE entry price")
    else:  # SHORT
        if stop_loss_price <= entry_price:
            validation_errors.append("‚ùå **SHORT trades**: Stop loss must be ABOVE entry price")
        if take_profit_price >= entry_price:
            validation_errors.append("‚ùå **SHORT trades**: Take profit must be BELOW entry price")
    
    if validation_errors:
        for error in validation_errors:
            st.error(error)
        st.info(f"""
        **{trade_direction} Trade Setup:**
        - Entry: {format_price(entry_price)}
        - Stop Loss should be: {'BELOW' if trade_direction == 'LONG' else 'ABOVE'} entry
        - Take Profit should be: {'ABOVE' if trade_direction == 'LONG' else 'BELOW'} entry
        """)
    
    if distance_to_stop > 0:
        position_size_units = risk_amount / distance_to_stop
        position_value = position_size_units * entry_price
        
        potential_loss = risk_amount
        
        # Calculate profit based on trade direction
        if trade_direction == "LONG":
            potential_profit = (take_profit_price - entry_price) * position_size_units
        else:  # SHORT
            potential_profit = (entry_price - take_profit_price) * position_size_units
        
        risk_reward_ratio = potential_profit / potential_loss if potential_loss > 0 and potential_profit > 0 else 0
        
        st.subheader("üìä Calculated Position Size")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "Risk Amount", 
                format_price(risk_amount),
                help="Maximum you'll lose if stop loss is hit"
            )
        
        with col2:
            st.metric(
                "Position Size", 
                f"{position_size_units:,.4f} units",
                help="Number of units/coins to buy"
            )
        
        with col3:
            st.metric(
                "Investment", 
                format_price(position_value),
                help="Total amount to invest"
            )
        
        with col4:
            rr_color = "normal" if risk_reward_ratio >= 2 else "inverse"
            st.metric(
                "Risk/Reward", 
                f"1:{risk_reward_ratio:.1f}",
                delta_color=rr_color,
                help="Risk vs potential reward ratio"
            )
        
        st.divider()
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üí∞ Profit & Loss Scenarios")
            st.write(f"**If Stop Loss is Hit ({format_price(stop_loss_price)}):**")
            st.error(f"‚ùå Loss: {format_price(potential_loss)} ({risk_percentage}% of capital)")
            
            st.write(f"**If Take Profit is Hit ({format_price(take_profit_price)}):**")
            if potential_profit > 0:
                profit_percentage = (potential_profit / total_capital) * 100
                st.success(f"‚úÖ Profit: {format_price(potential_profit)} ({profit_percentage:.2f}% of capital)")
            else:
                loss_percentage = abs((potential_profit / total_capital) * 100)
                st.error(f"‚ùå LOSS: {format_price(abs(potential_profit))} ({loss_percentage:.2f}% of capital)")
                st.warning(f"‚ö†Ô∏è This is a LOSS because for {trade_direction} trades, take profit must be {'above' if trade_direction == 'LONG' else 'below'} entry price!")
        
        with col2:
            st.subheader("üéØ Trade Quality Assessment")
            
            if risk_reward_ratio >= 3:
                st.success("‚úÖ **Excellent** risk/reward ratio (3:1 or better)")
            elif risk_reward_ratio >= 2:
                st.success("‚úÖ **Good** risk/reward ratio (2:1 to 3:1)")
            elif risk_reward_ratio >= 1.5:
                st.warning("‚ö†Ô∏è **Acceptable** risk/reward ratio (1.5:1 to 2:1)")
            else:
                st.error("‚ùå **Poor** risk/reward ratio (less than 1.5:1)\nConsider skipping this trade!")
            
            if position_value > total_capital:
                st.error(f"‚ùå **Warning**: Investment ({format_price(position_value)}) exceeds your capital!")
                st.write("**Solutions:**")
                st.write(f"‚Ä¢ Move stop loss closer to entry (currently {format_price(distance_to_stop)} away)")
                st.write(f"‚Ä¢ Reduce risk percentage (currently {risk_percentage}%)")
            elif position_value > total_capital * 0.3:
                st.warning(f"‚ö†Ô∏è This trade uses {(position_value/total_capital)*100:.1f}% of your capital")
                st.write("Consider diversifying across multiple trades")
            else:
                st.success(f"‚úÖ Trade size is {(position_value/total_capital)*100:.1f}% of capital - well diversified!")
        
        st.divider()
        
        st.subheader("üìù Summary")
        st.markdown(f"""
        **To execute this {trade_direction} trade:**
        1. {'Buy' if trade_direction == 'LONG' else 'Sell short'} **{position_size_units:,.4f} units** at **{format_price(entry_price)}**
        2. Total investment: **{format_price(position_value)}**
        3. Set stop loss at **{format_price(stop_loss_price)}** (risk: {format_price(potential_loss)})
        4. Set take profit at **{format_price(take_profit_price)}** (potential: {format_price(potential_profit)})
        5. Risk/Reward: **1:{risk_reward_ratio:.1f}**
        
        **If this looks good, you can add it to Position Tracker manually or use AI recommendations!**
        """)

elif menu == "Performance Analytics":
    st.header("üìä Performance Analytics")
    
    session = get_session()
    
    trades = session.query(Trade).filter(Trade.exit_price.isnot(None)).all()
    
    if trades:
        total_trades = len(trades)
        winning_trades = len([t for t in trades if t.outcome == 'win'])
        losing_trades = len([t for t in trades if t.outcome == 'loss'])
        win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Total Trades", total_trades)
        with col2:
            st.metric("Winning Trades", winning_trades)
        with col3:
            st.metric("Losing Trades", losing_trades)
        with col4:
            st.metric("Win Rate", f"{win_rate:.1f}%")
        
        # Calculate detailed P&L analytics
        wins = [t for t in trades if t.outcome == 'win' and t.profit_loss is not None]
        losses = [t for t in trades if t.outcome == 'loss' and t.profit_loss is not None]
        
        total_pnl = sum(t.profit_loss for t in trades if t.profit_loss is not None)
        avg_win = sum(t.profit_loss for t in wins) / len(wins) if wins else 0
        avg_loss = sum(t.profit_loss for t in losses) / len(losses) if losses else 0
        risk_reward_ratio = abs(avg_win / avg_loss) if avg_loss != 0 else 0
        
        # Prominent P&L Analytics Section
        st.divider()
        st.subheader("üí∞ Profit & Loss Analytics")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            pnl_color = "normal" if total_pnl >= 0 else "inverse"
            st.metric("Total P&L", f"${total_pnl:.2f}", delta_color=pnl_color)
        
        with col2:
            st.metric("Avg Win", f"${avg_win:.2f}", delta_color="normal" if avg_win > 0 else "off")
        
        with col3:
            st.metric("Avg Loss", f"${avg_loss:.2f}", delta_color="inverse" if avg_loss < 0 else "off")
        
        with col4:
            rr_color = "normal" if risk_reward_ratio >= 2 else "inverse"
            st.metric("Risk/Reward", f"1:{risk_reward_ratio:.2f}", delta_color=rr_color)
        
        # Performance Quality Assessment
        if risk_reward_ratio >= 2:
            st.success("‚úÖ **Excellent Risk/Reward** - Your wins are significantly larger than your losses!")
        elif risk_reward_ratio >= 1.5:
            st.info("üìä **Good Risk/Reward** - You're managing risk well, keep it up!")
        elif risk_reward_ratio >= 1:
            st.warning("‚ö†Ô∏è **Acceptable Risk/Reward** - Consider taking larger profits or cutting losses faster.")
        else:
            st.error("‚ùå **Poor Risk/Reward** - Your losses are larger than wins. Review your strategy!")
        
        # Win Rate vs R:R Analysis
        expected_value = (win_rate / 100 * avg_win) + ((100 - win_rate) / 100 * avg_loss)
        
        st.write(f"**Expected Value per Trade:** ${expected_value:.2f}")
        
        if expected_value > 0:
            st.success(f"‚úÖ Your trading strategy is profitable! Over time, you expect to make ${expected_value:.2f} per trade.")
        else:
            st.error(f"‚ùå Your strategy is losing money. Expected loss: ${expected_value:.2f} per trade. Adjust your approach!")
        
        st.divider()
        st.subheader("üìã Trade History")
        
        # Filter controls
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            all_symbols = sorted(list(set([t.symbol for t in trades])))
            filter_symbol = st.selectbox("Filter by Symbol", ["All"] + all_symbols, key="filter_symbol")
        
        with col2:
            filter_type = st.selectbox("Trade Type", ["All", "LONG", "SHORT"], key="filter_type")
        
        with col3:
            filter_outcome = st.selectbox("Outcome", ["All", "WIN", "LOSS"], key="filter_outcome")
        
        with col4:
            st.write("")
            st.write("")
            if st.button("üîÑ Reset Filters"):
                st.rerun()
        
        # Apply filters
        filtered_trades = trades
        if filter_symbol != "All":
            filtered_trades = [t for t in filtered_trades if t.symbol == filter_symbol]
        if filter_type != "All":
            filtered_trades = [t for t in filtered_trades if t.trade_type == filter_type]
        if filter_outcome != "All":
            filtered_trades = [t for t in filtered_trades if t.outcome == filter_outcome.lower()]
        
        st.caption(f"Showing {len(filtered_trades)} of {len(trades)} trades")
        
        for trade in reversed(filtered_trades):
            exit_time_riyadh = convert_to_riyadh_time(trade.exit_time) if trade.exit_time else None
            exit_time_str = exit_time_riyadh.strftime('%Y-%m-%d %H:%M') if exit_time_riyadh else 'N/A'
            
            with st.expander(f"{trade.symbol} ({trade.trade_type}) - {trade.outcome.upper()} - {exit_time_str}"):
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Entry Price", format_price(trade.entry_price))
                with col2:
                    st.metric("Exit Price", format_price(trade.exit_price))
                with col3:
                    pnl_color = "normal" if trade.profit_loss_percentage and trade.profit_loss_percentage >= 0 else "inverse"
                    st.metric("P&L", f"{trade.profit_loss_percentage:.2f}%" if trade.profit_loss_percentage else "N/A", delta_color=pnl_color)
                with col4:
                    outcome_emoji = "‚úÖ" if trade.outcome == "win" else "‚ùå"
                    st.metric("Outcome", f"{outcome_emoji} {trade.outcome.upper()}")
                
                col1, col2 = st.columns(2)
                
                with col1:
                    if trade.exit_type:
                        exit_emoji = "üéØ" if "TO Achieved" in trade.exit_type else "üë§"
                        st.write(f"**Exit Type:** {exit_emoji} {trade.exit_type}")
                    else:
                        st.write("**Exit Type:** Not recorded")
                    
                    entry_time_riyadh = convert_to_riyadh_time(trade.entry_time)
                    st.write(f"**Entry Time:** {entry_time_riyadh.strftime('%Y-%m-%d %H:%M')} (Riyadh)")
                    st.write(f"**Exit Time:** {exit_time_str} (Riyadh)" if exit_time_riyadh else "**Exit Time:** N/A")
                
                with col2:
                    if trade.quantity:
                        st.write(f"**Quantity:** {trade.quantity}")
                    if trade.profit_loss:
                        st.write(f"**Total P&L:** ${trade.profit_loss:.2f}")
                
                if trade.notes:
                    st.write("**Exit Notes:**")
                    st.info(trade.notes)
        
        st.divider()
        st.subheader("Model Performance")
        model_perf = session.query(ModelPerformance).filter(ModelPerformance.is_active == True).all()
        
        if model_perf:
            for model in model_perf:
                with st.expander(f"{model.model_name} - Accuracy: {model.accuracy*100:.1f}%"):
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Precision", f"{model.precision*100:.1f}%")
                    with col2:
                        st.metric("Recall", f"{model.recall*100:.1f}%")
                    with col3:
                        st.metric("F1 Score", f"{model.f1_score*100:.1f}%")
                    
                    training_time_riyadh = convert_to_riyadh_time(model.training_date)
                    st.write(f"Training Date: {training_time_riyadh.strftime('%Y-%m-%d %H:%M')} (Riyadh)")
                    st.write(f"Total Trades Used: {model.total_trades}")
        
        # Indicator Performance Analysis Dashboard
        st.subheader("üéØ Indicator Performance Analysis")
        
        from database import IndicatorPerformance
        indicator_perf = session.query(IndicatorPerformance).order_by(IndicatorPerformance.accuracy_rate.desc()).all()
        
        if indicator_perf:
            st.write("**Discover which indicators are most accurate for your trading!**")
            
            # Create indicator performance table
            perf_data = []
            for ind in indicator_perf:
                perf_data.append({
                    'Indicator': ind.indicator_name,
                    'Correct': ind.correct_count,
                    'Wrong': ind.wrong_count,
                    'Accuracy %': f"{ind.accuracy_rate:.1f}%",
                    'Weight': f"{ind.weight_multiplier:.2f}x",
                    'Total Signals': ind.total_signals
                })
            
            perf_df = pd.DataFrame(perf_data)
            st.dataframe(perf_df, use_container_width=True)
            
            # Visual bar chart of accuracy rates
            st.write("**Indicator Accuracy Rates:**")
            
            # Prepare data for chart
            indicators = [ind.indicator_name for ind in indicator_perf]
            accuracies = [ind.accuracy_rate for ind in indicator_perf]
            
            # Create bar chart
            fig = go.Figure(data=[
                go.Bar(
                    x=indicators,
                    y=accuracies,
                    marker_color=['green' if acc >= 50 else 'red' for acc in accuracies],
                    text=[f"{acc:.1f}%" for acc in accuracies],
                    textposition='outside'
                )
            ])
            
            fig.update_layout(
                title="Indicator Accuracy Comparison",
                xaxis_title="Indicator",
                yaxis_title="Accuracy %",
                yaxis=dict(range=[0, 100]),
                height=400,
                showlegend=False
            )
            
            # Add 50% reference line
            fig.add_hline(y=50, line_dash="dash", line_color="blue", 
                         annotation_text="50% (Random)", annotation_position="right")
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Key insights
            best_ind = max(indicator_perf, key=lambda x: x.accuracy_rate)
            worst_ind = min(indicator_perf, key=lambda x: x.accuracy_rate)
            
            col1, col2 = st.columns(2)
            with col1:
                st.success(f"**üèÜ Best Performer:** {best_ind.indicator_name} ({best_ind.accuracy_rate:.1f}%)")
            with col2:
                st.error(f"**üìâ Weakest:** {worst_ind.indicator_name} ({worst_ind.accuracy_rate:.1f}%)")
        else:
            st.info("Complete some trades to see individual indicator performance!")
    else:
        st.info("No completed trades yet. Start trading to see analytics!")
    
    session.close()

elif menu == "Model Training":
    st.header("ü§ñ AI Model Training")
    
    st.write("Train the AI models on your completed trades to improve prediction accuracy.")
    
    session = get_session()
    trades_count = session.query(Trade).filter(
        Trade.exit_price.isnot(None),
        Trade.outcome.isnot(None)
    ).count()
    session.close()
    
    st.info(f"Available trades for training: {trades_count}")
    
    if trades_count < 30:
        st.warning(f"‚ö†Ô∏è Minimum 30 trades required for training. You have {trades_count} trades.")
    
    min_trades = st.number_input("Minimum trades for training", min_value=10, value=30, step=5)
    
    if st.button("Train Models", type="primary", disabled=trades_count < 10):
        with st.spinner("Training AI models... This may take a few minutes."):
            ml_engine = MLTradingEngine()
            success = ml_engine.train_models(min_trades=min_trades)
            
            if success:
                st.success("‚úÖ Models trained successfully!")
                st.balloons()
            else:
                st.error("‚ùå Training failed. Make sure you have enough completed trades.")

st.sidebar.markdown("---")
st.sidebar.markdown("### About")
st.sidebar.info(
    "AI-powered trading platform with real-time analysis, "
    "ML predictions, and automated position monitoring."
)


================================================================================
2. position_monitor.py - POSITION MONITORING WITH 3-TIER PRIORITY
================================================================================

from datetime import datetime, timedelta
import time
from database import get_session, ActivePosition, MarketData
from api_integrations import get_market_data_unified, get_current_price
from technical_indicators import TechnicalIndicators, calculate_support_resistance
from whale_tracker import WhaleTracker
from divergence_resolver import resolve_active_divergences
import json

class PositionMonitor:
    def __init__(self):
        self.check_interval_minutes = 15
        
    def check_active_positions(self):
        session = get_session()
        results = []
        
        try:
            active_positions = session.query(ActivePosition).filter(
                ActivePosition.is_active == True
            ).all()
            
            for position in active_positions:
                result = self._analyze_position(position, session)
                results.append(result)
                
                position.last_check_time = datetime.utcnow()
                position.current_recommendation = result['recommendation']
                
                if result['current_price']:
                    position.current_price = result['current_price']
                
                session.commit()
            
            return results
            
        except Exception as e:
            print(f"Error checking positions: {e}")
            session.rollback()
            return []
        finally:
            session.close()
    
    def _analyze_position(self, position, session):
        try:
            current_price = get_current_price(position.symbol, position.market_type)
            
            if not current_price:
                return {
                    'symbol': position.symbol,
                    'status': 'error',
                    'message': 'Unable to fetch current price',
                    'recommendation': 'HOLD',
                    'current_price': None,
                    'monitoring_alerts': []
                }
            
            timeframe = getattr(position, 'timeframe', '1H') or '1H'
            df = get_market_data_unified(position.symbol, position.market_type, timeframe, 100)
            
            if df is None or len(df) < 20:
                return {
                    'symbol': position.symbol,
                    'status': 'error',
                    'message': 'Unable to fetch market data',
                    'recommendation': 'HOLD',
                    'current_price': current_price,
                    'monitoring_alerts': []
                }
            
            tech_indicators = TechnicalIndicators(df)
            tech_indicators.calculate_all_indicators()
            indicators = tech_indicators.get_latest_indicators()
            signals = tech_indicators.get_trend_signals()
            
            monitoring_alerts = self._check_tight_monitoring(
                position, current_price, indicators, signals
            )
            
            # Get historical trend context for duration-aware monitoring
            trend_context = tech_indicators.get_trend_context(position.symbol, position.market_type)
            
            # Check and resolve active divergences (timing intelligence)
            try:
                resolve_active_divergences(position.symbol, current_price, trend_context)
            except Exception as e:
                print(f"Divergence resolution check failed: {e}")
            
            support_levels, resistance_levels = calculate_support_resistance(df)
            
            whale_tracker = WhaleTracker(tech_indicators.df)
            whale_movements = whale_tracker.detect_whale_movements()
            smart_money = whale_tracker.detect_smart_money()
            
            entry_price = position.entry_price
            pnl_percentage = ((current_price - entry_price) / entry_price) * 100
            
            if position.trade_type == 'SHORT':
                pnl_percentage = -pnl_percentage
            
            recommendation = self._generate_recommendation(
                position, current_price, pnl_percentage, signals, 
                support_levels, resistance_levels, whale_movements, smart_money,
                monitoring_alerts
            )
            
            market_data = MarketData(
                symbol=position.symbol,
                market_type=position.market_type,
                timestamp=datetime.utcnow(),
                open_price=float(df.iloc[-1]['open']),
                high_price=float(df.iloc[-1]['high']),
                low_price=float(df.iloc[-1]['low']),
                close_price=float(df.iloc[-1]['close']),
                volume=float(df.iloc[-1]['volume']),
                indicators=indicators
            )
            session.add(market_data)
            
            current_obv_slope = indicators.get('obv_slope', 0)
            position.last_obv_slope = current_obv_slope
            position.monitoring_alerts = monitoring_alerts
            
            return {
                'symbol': position.symbol,
                'trade_type': position.trade_type,
                'entry_price': entry_price,
                'current_price': current_price,
                'pnl_percentage': round(pnl_percentage, 2),
                'recommendation': recommendation['action'],
                'reason': recommendation['reason'],
                'signals': signals,
                'support_levels': support_levels,
                'resistance_levels': resistance_levels,
                'whale_activity': len(whale_movements) > 0,
                'smart_money_signal': smart_money[0]['type'] if smart_money else None,
                'monitoring_alerts': monitoring_alerts,
                'status': 'success'
            }
            
        except Exception as e:
            print(f"Error analyzing position {position.symbol}: {e}")
            return {
                'symbol': position.symbol,
                'status': 'error',
                'message': str(e),
                'recommendation': 'HOLD',
                'current_price': None,
                'monitoring_alerts': []
            }
    
    def _check_tight_monitoring(self, position, current_price, indicators, signals):
        alerts = []
        
        if not position.stop_loss:
            return alerts
        
        entry_price = position.entry_price
        stop_loss = position.stop_loss
        
        if position.trade_type == 'SHORT':
            distance_to_sl = stop_loss - entry_price
            
            if distance_to_sl <= 0:
                return alerts
            
            current_distance = current_price - entry_price
            threshold_price = entry_price + (distance_to_sl * 0.6)
            
            if current_price >= threshold_price:
                pct_to_sl = (current_distance / distance_to_sl) * 100
                alerts.append({
                    'type': 'DANGER_ZONE',
                    'severity': 'HIGH',
                    'message': f'‚ö†Ô∏è Price at ${current_price:,.2f} - {pct_to_sl:.0f}% to stop loss (${stop_loss:,.2f})',
                    'recommendation': 'CONSIDER EXIT - Approaching stop loss'
                })
            
            obv_slope = indicators.get('obv_slope', 0)
            if obv_slope > 0 and position.last_obv_slope and position.last_obv_slope < 0:
                alerts.append({
                    'type': 'OBV_FLIP',
                    'severity': 'HIGH',
                    'message': f'üîÑ OBV flipped BULLISH (slope: +{obv_slope:,.0f}) - Smart money buying',
                    'recommendation': 'CONSIDER EXIT - Momentum against SHORT position'
                })
            elif obv_slope > 0:
                alerts.append({
                    'type': 'OBV_WARNING',
                    'severity': 'MEDIUM',
                    'message': f'üìà OBV rising (+{obv_slope:,.0f}) - Smart money accumulating',
                    'recommendation': 'Monitor closely - Trend against SHORT'
                })
        
        elif position.trade_type == 'LONG':
            distance_to_sl = entry_price - stop_loss
            
            if distance_to_sl <= 0:
                return alerts
            
            current_distance = entry_price - current_price
            threshold_price = entry_price - (distance_to_sl * 0.6)
            
            if current_price <= threshold_price:
                pct_to_sl = (current_distance / distance_to_sl) * 100
                alerts.append({
                    'type': 'DANGER_ZONE',
                    'severity': 'HIGH',
                    'message': f'‚ö†Ô∏è Price at ${current_price:,.2f} - {pct_to_sl:.0f}% to stop loss (${stop_loss:,.2f})',
                    'recommendation': 'CONSIDER EXIT - Approaching stop loss'
                })
            
            obv_slope = indicators.get('obv_slope', 0)
            if obv_slope < 0 and position.last_obv_slope and position.last_obv_slope > 0:
                alerts.append({
                    'type': 'OBV_FLIP',
                    'severity': 'HIGH',
                    'message': f'üîÑ OBV flipped BEARISH (slope: {obv_slope:,.0f}) - Smart money selling',
                    'recommendation': 'CONSIDER EXIT - Momentum against LONG position'
                })
            elif obv_slope < 0:
                alerts.append({
                    'type': 'OBV_WARNING',
                    'severity': 'MEDIUM',
                    'message': f'üìâ OBV falling ({obv_slope:,.0f}) - Smart money distributing',
                    'recommendation': 'Monitor closely - Trend against LONG'
                })
        
        return alerts
    
    def _generate_recommendation(self, position, current_price, pnl_percentage, 
                                 signals, support_levels, resistance_levels,
                                 whale_movements, smart_money, monitoring_alerts=None):
        
        reasons = []
        
        # PRIORITY 1: Check HIGH severity monitoring alerts (approaching stop loss, OBV flip)
        if monitoring_alerts:
            high_severity_alerts = [alert for alert in monitoring_alerts if alert.get('severity') == 'HIGH']
            if high_severity_alerts:
                alert_messages = [alert.get('message', '') for alert in high_severity_alerts]
                return {
                    'action': 'EXIT',
                    'reason': f"‚ö†Ô∏è RISK ALERT: {'; '.join(alert_messages)}"
                }
        
        # PRIORITY 2: Check if stop loss actually hit
        if position.stop_loss:
            if position.trade_type == 'LONG' and current_price <= position.stop_loss:
                return {
                    'action': 'EXIT',
                    'reason': 'Stop loss hit'
                }
            elif position.trade_type == 'SHORT' and current_price >= position.stop_loss:
                return {
                    'action': 'EXIT',
                    'reason': 'Stop loss hit'
                }
        
        if position.take_profit:
            if position.trade_type == 'LONG' and current_price >= position.take_profit:
                return {
                    'action': 'EXIT',
                    'reason': 'Take profit target reached'
                }
            elif position.trade_type == 'SHORT' and current_price <= position.take_profit:
                return {
                    'action': 'EXIT',
                    'reason': 'Take profit target reached'
                }
        
        bearish_count = 0
        bullish_count = 0
        
        for indicator, signal in signals.items():
            if signal in ['bearish', 'overbought', 'strong_downtrend']:
                bearish_count += 1
            elif signal in ['bullish', 'oversold', 'strong_uptrend']:
                bullish_count += 1
        
        if position.trade_type == 'LONG':
            if bearish_count >= 4:
                reasons.append(f"Bearish signals detected ({bearish_count} indicators)")
                return {
                    'action': 'EXIT',
                    'reason': ', '.join(reasons)
                }
            
            if resistance_levels and current_price >= resistance_levels[0] * 0.98:
                reasons.append(f"Approaching resistance at {resistance_levels[0]}")
            
            if pnl_percentage > 5:
                reasons.append(f"Profit target reached: +{pnl_percentage:.2f}%")
                return {
                    'action': 'EXIT',
                    'reason': ', '.join(reasons)
                }
        
        elif position.trade_type == 'SHORT':
            if bullish_count >= 4:
                reasons.append(f"Bullish signals detected ({bullish_count} indicators)")
                return {
                    'action': 'EXIT',
                    'reason': ', '.join(reasons)
                }
            
            if support_levels and current_price <= support_levels[0] * 1.02:
                reasons.append(f"Approaching support at {support_levels[0]}")
            
            if pnl_percentage > 5:
                reasons.append(f"Profit target reached: +{pnl_percentage:.2f}%")
                return {
                    'action': 'EXIT',
                    'reason': ', '.join(reasons)
                }
        
        if smart_money:
            latest_signal = smart_money[0]
            if position.trade_type == 'LONG' and latest_signal['type'] == 'distribution':
                reasons.append("Smart money distribution detected")
                return {
                    'action': 'EXIT',
                    'reason': ', '.join(reasons)
                }
            elif position.trade_type == 'SHORT' and latest_signal['type'] == 'accumulation':
                reasons.append("Smart money accumulation detected")
                return {
                    'action': 'EXIT',
                    'reason': ', '.join(reasons)
                }
        
        if pnl_percentage < -3:
            reasons.append(f"Position in loss: {pnl_percentage:.2f}%")
            
            if position.trade_type == 'LONG' and bearish_count > bullish_count:
                return {
                    'action': 'EXIT',
                    'reason': 'Cutting losses - trend against position'
                }
            elif position.trade_type == 'SHORT' and bullish_count > bearish_count:
                return {
                    'action': 'EXIT',
                    'reason': 'Cutting losses - trend against position'
                }
        
        hold_reasons = []
        if position.trade_type == 'LONG' and bullish_count > bearish_count:
            hold_reasons.append("Trend still bullish")
        elif position.trade_type == 'SHORT' and bearish_count > bullish_count:
            hold_reasons.append("Trend still bearish")
        else:
            hold_reasons.append("No clear exit signal")
        
        return {
            'action': 'HOLD',
            'reason': ', '.join(hold_reasons) if hold_reasons else 'Position looks healthy'
        }
    
    def add_position(self, symbol, market_type, trade_type, entry_price, 
                     quantity=None, stop_loss=None, take_profit=None, timeframe='1H', indicators=None):
        session = get_session()
        
        try:
            existing = session.query(ActivePosition).filter(
                ActivePosition.symbol == symbol,
                ActivePosition.is_active == True
            ).first()
            
            if existing:
                return {
                    'success': False,
                    'message': f'Active position already exists for {symbol}'
                }
            
            position = ActivePosition(
                symbol=symbol,
                market_type=market_type,
                trade_type=trade_type,
                entry_price=entry_price,
                quantity=quantity,
                stop_loss=stop_loss,
                take_profit=take_profit,
                timeframe=timeframe,
                entry_time=datetime.utcnow(),
                current_price=entry_price,
                is_active=True,
                indicators_snapshot=indicators
            )
            
            session.add(position)
            session.commit()
            
            return {
                'success': True,
                'message': f'Position added for {symbol}',
                'position_id': position.id
            }
            
        except Exception as e:
            session.rollback()
            return {
                'success': False,
                'message': f'Error adding position: {str(e)}'
            }
        finally:
            session.close()
    
    def close_position(self, symbol, exit_price, outcome, exit_type=None, notes=None):
        session = get_session()
        
        try:
            position = session.query(ActivePosition).filter(
                ActivePosition.symbol == symbol,
                ActivePosition.is_active == True
            ).first()
            
            if not position:
                return {
                    'success': False,
                    'message': f'No active position found for {symbol}'
                }
            
            position.is_active = False
            
            from database import Trade
            trade = Trade(
                symbol=position.symbol,
                market_type=position.market_type,
                trade_type=position.trade_type,
                entry_price=position.entry_price,
                exit_price=exit_price,
                entry_time=position.entry_time,
                exit_time=datetime.utcnow(),
                quantity=position.quantity,
                outcome=outcome,
                exit_type=exit_type,
                notes=notes,
                indicators_at_entry=position.indicators_snapshot
            )
            
            # Calculate P&L percentage (works even without quantity)
            if position.trade_type == 'LONG':
                price_diff = exit_price - position.entry_price
            else:  # SHORT
                price_diff = position.entry_price - exit_price
            
            trade.profit_loss_percentage = (price_diff / position.entry_price) * 100
            
            # Calculate absolute P&L only if quantity is specified
            if position.quantity:
                trade.profit_loss = price_diff * position.quantity
            else:
                # Use a default quantity of 1 for absolute P&L if not specified
                trade.profit_loss = price_diff
            
            session.add(trade)
            session.commit()
            
            from ml_engine import MLTradingEngine
            ml_engine = MLTradingEngine()
            ml_engine.learn_from_trade(trade.id)
            
            return {
                'success': True,
                'message': f'Position closed for {symbol}',
                'trade_id': trade.id
            }
            
        except Exception as e:
            session.rollback()
            return {
                'success': False,
                'message': f'Error closing position: {str(e)}'
            }
        finally:
            session.close()
    
    def update_entry_price(self, symbol, new_entry_price):
        """Update the entry price of an active position"""
        session = get_session()
        
        try:
            position = session.query(ActivePosition).filter(
                ActivePosition.symbol == symbol,
                ActivePosition.is_active == True
            ).first()
            
            if not position:
                return {
                    'success': False,
                    'message': f'No active position found for {symbol}'
                }
            
            old_entry = position.entry_price
            position.entry_price = new_entry_price
            
            session.commit()
            
            return {
                'success': True,
                'message': f'Entry price updated from ${old_entry:,.2f} to ${new_entry_price:,.2f}',
                'old_price': old_entry,
                'new_price': new_entry_price
            }
            
        except Exception as e:
            session.rollback()
            return {
                'success': False,
                'message': f'Error updating entry price: {str(e)}'
            }
        finally:
            session.close()


================================================================================
3. technical_indicators.py - 12+ INDICATORS WITH TREND CONTEXT
================================================================================

import pandas as pd
import numpy as np
import pandas_ta as ta

class TechnicalIndicators:
    def __init__(self, df):
        self.df = df.copy()
        self.df = self.df.sort_values('timestamp').reset_index(drop=True)
        
    def calculate_all_indicators(self):
        df = self.df.copy()
        
        df['RSI'] = ta.rsi(df['close'], length=14)
        
        macd = ta.macd(df['close'], fast=12, slow=26, signal=9)
        if macd is not None:
            df['MACD'] = macd['MACD_12_26_9']
            df['MACD_signal'] = macd['MACDs_12_26_9']
            df['MACD_hist'] = macd['MACDh_12_26_9']
        
        stoch = ta.stoch(df['high'], df['low'], df['close'], k=14, d=3, smooth_k=3)
        if stoch is not None:
            df['Stoch_K'] = stoch['STOCHk_14_3_3']
            df['Stoch_D'] = stoch['STOCHd_14_3_3']
        
        df['OBV'] = ta.obv(df['close'], df['volume'])
        
        df['MFI'] = ta.mfi(df['high'], df['low'], df['close'], df['volume'], length=14)
        
        df['CCI'] = ta.cci(df['high'], df['low'], df['close'], length=20)
        
        adx = ta.adx(df['high'], df['low'], df['close'], length=14)
        if adx is not None:
            df['ADX'] = adx['ADX_14']
            df['DI_plus'] = adx['DMP_14']
            df['DI_minus'] = adx['DMN_14']
        
        df['SMA_20'] = ta.sma(df['close'], length=20)
        df['SMA_50'] = ta.sma(df['close'], length=50)
        df['SMA_200'] = ta.sma(df['close'], length=200)
        
        df['EMA_12'] = ta.ema(df['close'], length=12)
        df['EMA_26'] = ta.ema(df['close'], length=26)
        df['EMA_50'] = ta.ema(df['close'], length=50)
        
        bbands = ta.bbands(df['close'], length=20, std=2)
        if bbands is not None and not bbands.empty:
            bbu_col = [col for col in bbands.columns if col.startswith('BBU')]
            bbm_col = [col for col in bbands.columns if col.startswith('BBM')]
            bbl_col = [col for col in bbands.columns if col.startswith('BBL')]
            
            if bbu_col and bbm_col and bbl_col:
                df['BB_upper'] = bbands[bbu_col[0]]
                df['BB_middle'] = bbands[bbm_col[0]]
                df['BB_lower'] = bbands[bbl_col[0]]
        
        df['ATR'] = ta.atr(df['high'], df['low'], df['close'], length=14)
        
        df['Volume_SMA'] = ta.sma(df['volume'], length=20)
        
        self.df = df
        return df
    
    def get_latest_indicators(self):
        if len(self.df) == 0:
            return {}
        
        latest = self.df.iloc[-1]
        indicators = {
            'RSI': latest.get('RSI'),
            'MACD': latest.get('MACD'),
            'MACD_signal': latest.get('MACD_signal'),
            'MACD_hist': latest.get('MACD_hist'),
            'Stoch_K': latest.get('Stoch_K'),
            'Stoch_D': latest.get('Stoch_D'),
            'OBV': latest.get('OBV'),
            'MFI': latest.get('MFI'),
            'CCI': latest.get('CCI'),
            'ADX': latest.get('ADX'),
            'DI_plus': latest.get('DI_plus'),
            'DI_minus': latest.get('DI_minus'),
            'SMA_20': latest.get('SMA_20'),
            'SMA_50': latest.get('SMA_50'),
            'SMA_200': latest.get('SMA_200'),
            'EMA_12': latest.get('EMA_12'),
            'EMA_26': latest.get('EMA_26'),
            'EMA_50': latest.get('EMA_50'),
            'BB_upper': latest.get('BB_upper'),
            'BB_middle': latest.get('BB_middle'),
            'BB_lower': latest.get('BB_lower'),
            'ATR': latest.get('ATR'),
            'Volume_SMA': latest.get('Volume_SMA'),
            'current_price': latest.get('close'),
            'volume': latest.get('volume')
        }
        
        return {k: float(v) if pd.notna(v) else None for k, v in indicators.items()}
    
    def get_trend_signals(self):
        indicators = self.get_latest_indicators()
        signals = {}
        
        if indicators.get('RSI') is not None:
            rsi = indicators['RSI']
            if rsi < 30:
                signals['RSI'] = 'oversold'
            elif rsi > 70:
                signals['RSI'] = 'overbought'
            else:
                signals['RSI'] = 'neutral'
        
        if indicators.get('MACD') and indicators.get('MACD_signal'):
            if indicators['MACD'] > indicators['MACD_signal']:
                signals['MACD'] = 'bullish'
            else:
                signals['MACD'] = 'bearish'
        
        if indicators.get('Stoch_K') is not None:
            stoch_k = indicators['Stoch_K']
            if stoch_k < 20:
                signals['Stochastic'] = 'oversold'
            elif stoch_k > 80:
                signals['Stochastic'] = 'overbought'
            else:
                signals['Stochastic'] = 'neutral'
        
        if indicators.get('ADX') is not None:
            adx = indicators['ADX']
            if adx > 25:
                if indicators.get('DI_plus', 0) > indicators.get('DI_minus', 0):
                    signals['ADX'] = 'strong_uptrend'
                else:
                    signals['ADX'] = 'strong_downtrend'
            else:
                signals['ADX'] = 'weak_trend'
        
        current_price = indicators.get('current_price')
        if current_price and indicators.get('BB_upper') and indicators.get('BB_lower'):
            if current_price > indicators['BB_upper']:
                signals['Bollinger'] = 'overbought'
            elif current_price < indicators['BB_lower']:
                signals['Bollinger'] = 'oversold'
            else:
                signals['Bollinger'] = 'neutral'
        
        if current_price:
            ma_signals = []
            if indicators.get('SMA_20'):
                ma_signals.append('bullish' if current_price > indicators['SMA_20'] else 'bearish')
            if indicators.get('SMA_50'):
                ma_signals.append('bullish' if current_price > indicators['SMA_50'] else 'bearish')
            if indicators.get('EMA_12'):
                ma_signals.append('bullish' if current_price > indicators['EMA_12'] else 'bearish')
            
            if ma_signals:
                bullish_count = ma_signals.count('bullish')
                signals['Moving_Averages'] = 'bullish' if bullish_count > len(ma_signals) / 2 else 'bearish'
        
        return signals
    
    def detect_candlestick_patterns(self):
        """Detect common candlestick patterns in the most recent candles"""
        if len(self.df) < 3:
            return {}
        
        patterns = {}
        
        # Get last 3 candles
        df = self.df.tail(3).reset_index(drop=True)
        
        # Current candle (most recent)
        curr = df.iloc[-1]
        prev = df.iloc[-2] if len(df) >= 2 else None
        prev2 = df.iloc[-3] if len(df) >= 3 else None
        
        # Calculate candle properties
        curr_body = abs(curr['close'] - curr['open'])
        curr_range = curr['high'] - curr['low']
        curr_upper_shadow = curr['high'] - max(curr['open'], curr['close'])
        curr_lower_shadow = min(curr['open'], curr['close']) - curr['low']
        
        # HAMMER (Bullish reversal)
        # Small body at top, long lower shadow (2-3x body), small upper shadow
        if curr_range > 0:
            if (curr_lower_shadow >= 2 * curr_body and 
                curr_upper_shadow <= 0.1 * curr_range and
                curr_body >= 0.1 * curr_range):
                patterns['Hammer'] = 'bullish'
        
        # SHOOTING STAR (Bearish reversal)
        # Small body at bottom, long upper shadow (2-3x body), small lower shadow
        if curr_range > 0:
            if (curr_upper_shadow >= 2 * curr_body and
                curr_lower_shadow <= 0.1 * curr_range and
                curr_body >= 0.1 * curr_range):
                patterns['Shooting_Star'] = 'bearish'
        
        # DOJI (Indecision)
        # Very small body (open ‚âà close)
        if curr_range > 0 and curr_body <= 0.05 * curr_range:
            patterns['Doji'] = 'neutral'
        
        # BULLISH ENGULFING (Bullish reversal)
        if prev is not None:
            prev_body = abs(prev['close'] - prev['open'])
            if (prev['close'] < prev['open'] and  # Previous red
                curr['close'] > curr['open'] and  # Current green
                curr['open'] < prev['close'] and  # Opens below prev close
                curr['close'] > prev['open']):    # Closes above prev open
                patterns['Bullish_Engulfing'] = 'bullish'
        
        # BEARISH ENGULFING (Bearish reversal)
        if prev is not None:
            if (prev['close'] > prev['open'] and  # Previous green
                curr['close'] < curr['open'] and  # Current red
                curr['open'] > prev['close'] and  # Opens above prev close
                curr['close'] < prev['open']):    # Closes below prev open
                patterns['Bearish_Engulfing'] = 'bearish'
        
        # MORNING STAR (Bullish reversal - 3 candle pattern)
        if prev is not None and prev2 is not None:
            prev2_body = abs(prev2['close'] - prev2['open'])
            prev_body = abs(prev['close'] - prev['open'])
            
            if (prev2['close'] < prev2['open'] and  # First: large red
                prev_body < prev2_body * 0.3 and     # Second: small body (doji-like)
                curr['close'] > curr['open'] and     # Third: green
                curr['close'] > (prev2['open'] + prev2['close']) / 2):  # Closes above midpoint
                patterns['Morning_Star'] = 'bullish'
        
        # EVENING STAR (Bearish reversal - 3 candle pattern)
        if prev is not None and prev2 is not None:
            prev2_body = abs(prev2['close'] - prev2['open'])
            prev_body = abs(prev['close'] - prev['open'])
            
            if (prev2['close'] > prev2['open'] and  # First: large green
                prev_body < prev2_body * 0.3 and     # Second: small body (doji-like)
                curr['close'] < curr['open'] and     # Third: red
                curr['close'] < (prev2['open'] + prev2['close']) / 2):  # Closes below midpoint
                patterns['Evening_Star'] = 'bearish'
        
        return patterns
    
    def get_pattern_signals(self):
        """Get trading signals from candlestick patterns"""
        patterns = self.detect_candlestick_patterns()
        
        if not patterns:
            return 'neutral'
        
        # Count bullish vs bearish signals
        bullish_count = sum(1 for signal in patterns.values() if signal == 'bullish')
        bearish_count = sum(1 for signal in patterns.values() if signal == 'bearish')
        
        if bullish_count > bearish_count:
            return 'bullish'
        elif bearish_count > bullish_count:
            return 'bearish'
        else:
            return 'neutral'
    
    def get_indicator_history(self, symbol, market_type, lookback=50):
        """
        Query historical indicator data from MarketData table.
        Returns list of indicator snapshots (most recent last).
        """
        from database import get_session, MarketData
        
        session = get_session()
        try:
            # Query last N market data records for this symbol
            records = session.query(MarketData).filter(
                MarketData.symbol == symbol,
                MarketData.market_type == market_type,
                MarketData.indicators.isnot(None)
            ).order_by(MarketData.timestamp.desc()).limit(lookback).all()
            
            # Reverse to get chronological order (oldest first)
            records = list(reversed(records))
            
            # Extract indicator values from JSON
            history = []
            for record in records:
                if record.indicators:
                    snapshot = {
                        'timestamp': record.timestamp,
                        'close_price': record.close_price,
                        **record.indicators  # Unpack all indicators
                    }
                    history.append(snapshot)
            
            return history
            
        except Exception as e:
            print(f"Error getting indicator history: {e}")
            return []
        finally:
            session.close()
    
    def _calculate_duration(self, history, indicator_name, threshold_low, threshold_high):
        """
        Calculate how many consecutive candles an indicator has been in a zone.
        Returns: (duration_candles, zone_type)
        zone_type: 'oversold', 'overbought', 'neutral'
        """
        if not history or len(history) == 0:
            return 0, 'neutral'
        
        duration = 0
        zone_type = 'neutral'
        
        # Check current state
        current_value = history[-1].get(indicator_name)
        if current_value is None:
            return 0, 'neutral'
        
        if current_value < threshold_low:
            zone_type = 'oversold'
        elif current_value > threshold_high:
            zone_type = 'overbought'
        else:
            return 0, 'neutral'
        
        # Count backwards while in same zone
        for i in range(len(history) - 1, -1, -1):
            value = history[i].get(indicator_name)
            if value is None:
                break
            
            if zone_type == 'oversold' and value < threshold_low:
                duration += 1
            elif zone_type == 'overbought' and value > threshold_high:
                duration += 1
            else:
                break
        
        return duration, zone_type
    
    def _calculate_slope(self, history, indicator_name, window=10):
        """
        Calculate slope/momentum of an indicator using linear regression.
        Positive slope = rising, negative slope = falling.
        """
        if not history or len(history) < window:
            return 0.0
        
        # Get last N values
        recent = history[-window:]
        values = [h.get(indicator_name) for h in recent if h.get(indicator_name) is not None]
        
        if len(values) < 3:
            return 0.0
        
        # Simple linear regression
        x = np.arange(len(values))
        y = np.array(values, dtype=float)
        
        # Calculate slope using least squares
        n = len(x)
        slope = (n * np.sum(x * y) - np.sum(x) * np.sum(y)) / (n * np.sum(x * x) - np.sum(x) ** 2)
        
        return float(slope)
    
    def _detect_divergence(self, history, indicator_name, window=10):
        """
        Detect divergence between price and indicator.
        Bullish divergence: Price falling but indicator rising
        Bearish divergence: Price rising but indicator falling
        """
        if not history or len(history) < window:
            return 'none'
        
        # Get price and indicator slopes
        recent = history[-window:]
        prices = [h.get('close_price') for h in recent if h.get('close_price') is not None]
        indicator_values = [h.get(indicator_name) for h in recent if h.get(indicator_name) is not None]
        
        if len(prices) < 3 or len(indicator_values) < 3:
            return 'none'
        
        # Calculate slopes
        price_x = np.arange(len(prices))
        price_y = np.array(prices, dtype=float)
        price_slope = (len(price_x) * np.sum(price_x * price_y) - np.sum(price_x) * np.sum(price_y)) / \
                     (len(price_x) * np.sum(price_x * price_x) - np.sum(price_x) ** 2)
        
        ind_x = np.arange(len(indicator_values))
        ind_y = np.array(indicator_values, dtype=float)
        ind_slope = (len(ind_x) * np.sum(ind_x * ind_y) - np.sum(ind_x) * np.sum(ind_y)) / \
                   (len(ind_x) * np.sum(ind_x * ind_x) - np.sum(ind_x) ** 2)
        
        # Detect divergence (slopes have opposite signs)
        if price_slope < -0.01 and ind_slope > 0.01:
            return 'bullish'  # Price falling, indicator rising
        elif price_slope > 0.01 and ind_slope < -0.01:
            return 'bearish'  # Price rising, indicator falling
        else:
            return 'none'
    
    def get_trend_context(self, symbol, market_type):
        """
        Get comprehensive trend context for key indicators.
        Returns dict with duration, slope, and divergence for RSI, Stochastic, MFI, and OBV.
        """
        history = self.get_indicator_history(symbol, market_type, lookback=50)
        
        if not history:
            return {}
        
        context = {}
        
        # RSI Analysis
        rsi_duration, rsi_zone = self._calculate_duration(history, 'RSI', 30, 70)
        rsi_slope = self._calculate_slope(history, 'RSI', window=10)
        rsi_divergence = self._detect_divergence(history, 'RSI', window=10)
        
        context['RSI'] = {
            'zone': rsi_zone,
            'duration_candles': rsi_duration,
            'slope': rsi_slope,
            'divergence': rsi_divergence
        }
        
        # Stochastic Analysis
        stoch_duration, stoch_zone = self._calculate_duration(history, 'Stoch_K', 20, 80)
        stoch_slope = self._calculate_slope(history, 'Stoch_K', window=10)
        stoch_divergence = self._detect_divergence(history, 'Stoch_K', window=10)
        
        context['Stochastic'] = {
            'zone': stoch_zone,
            'duration_candles': stoch_duration,
            'slope': stoch_slope,
            'divergence': stoch_divergence
        }
        
        # MFI Analysis
        mfi_duration, mfi_zone = self._calculate_duration(history, 'MFI', 20, 80)
        mfi_slope = self._calculate_slope(history, 'MFI', window=10)
        mfi_divergence = self._detect_divergence(history, 'MFI', window=10)
        
        context['MFI'] = {
            'zone': mfi_zone,
            'duration_candles': mfi_duration,
            'slope': mfi_slope,
            'divergence': mfi_divergence
        }
        
        # OBV Analysis (Volume-based)
        # OBV doesn't have zones like RSI, only slope and divergence
        obv_slope = self._calculate_slope(history, 'OBV', window=10)
        obv_divergence = self._detect_divergence(history, 'OBV', window=10)
        
        context['OBV'] = {
            'slope': obv_slope,
            'divergence': obv_divergence
        }
        
        return context

def calculate_support_resistance(df, lookback=20):
    if len(df) < lookback:
        return [], []
    
    recent_df = df.tail(lookback * 3)
    
    highs = recent_df['high'].values
    lows = recent_df['low'].values
    
    resistance_levels = []
    support_levels = []
    
    for i in range(lookback, len(highs) - lookback):
        if highs[i] == max(highs[i-lookback:i+lookback+1]):
            resistance_levels.append(highs[i])
        
        if lows[i] == min(lows[i-lookback:i+lookback+1]):
            support_levels.append(lows[i])
    
    resistance_levels = sorted(list(set([round(r, 2) for r in resistance_levels])), reverse=True)[:3]
    support_levels = sorted(list(set([round(s, 2) for s in support_levels])), reverse=True)[:3]
    
    current_price = df.iloc[-1]['close']
    resistance_levels = [r for r in resistance_levels if r > current_price]
    support_levels = [s for s in support_levels if s < current_price]
    
    pivot_high = df.tail(10)['high'].max()
    pivot_low = df.tail(10)['low'].min()
    pivot_close = df.iloc[-1]['close']
    
    pivot = (pivot_high + pivot_low + pivot_close) / 3
    r1 = 2 * pivot - pivot_low
    s1 = 2 * pivot - pivot_high
    r2 = pivot + (pivot_high - pivot_low)
    s2 = pivot - (pivot_high - pivot_low)
    
    for level in [r1, r2]:
        if level > current_price and level not in resistance_levels:
            resistance_levels.append(round(level, 2))
    
    for level in [s1, s2]:
        if level < current_price and level not in support_levels:
            support_levels.append(round(level, 2))
    
    resistance_levels = sorted(resistance_levels)[:3]
    support_levels = sorted(support_levels, reverse=True)[:3]
    
    return support_levels, resistance_levels


================================================================================
4. ml_engine.py - DUAL ML MODELS (RANDOM FOREST + XGBOOST)
================================================================================

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from xgboost import XGBClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import joblib
import os
from datetime import datetime
from database import get_session, Trade, ModelPerformance, IndicatorPerformance

class MLTradingEngine:
    def __init__(self):
        self.rf_model = None
        self.xgb_model = None
        self.scaler = StandardScaler()
        self.feature_columns = []
        self.model_dir = 'models'
        
        self.indicator_weights = {
            'RSI': 2.0,
            'MACD': 2.0,
            'ADX': 2.0,
            'Stoch_K': 1.0,
            'MFI': 1.0,
            'CCI': 1.0,
            'SMA': 1.0
        }
        
        if not os.path.exists(self.model_dir):
            os.makedirs(self.model_dir)
        
        self._load_indicator_weights()
    
    def prepare_features(self, indicators):
        features = []
        feature_names = [
            'RSI', 'MACD', 'MACD_hist', 'Stoch_K', 'Stoch_D',
            'MFI', 'CCI', 'ADX', 'DI_plus', 'DI_minus',
            'current_price', 'SMA_20', 'SMA_50', 'EMA_12', 'EMA_26',
            'BB_upper', 'BB_middle', 'BB_lower', 'ATR', 'volume', 'Volume_SMA'
        ]
        
        for feat in feature_names:
            val = indicators.get(feat)
            if val is not None and not pd.isna(val):
                features.append(float(val))
            else:
                features.append(0.0)
        
        if indicators.get('current_price') and indicators.get('SMA_20'):
            features.append((indicators['current_price'] - indicators['SMA_20']) / indicators['SMA_20'])
        else:
            features.append(0.0)
        
        if indicators.get('current_price') and indicators.get('SMA_50'):
            features.append((indicators['current_price'] - indicators['SMA_50']) / indicators['SMA_50'])
        else:
            features.append(0.0)
        
        if indicators.get('MACD') and indicators.get('MACD_signal'):
            features.append(indicators['MACD'] - indicators['MACD_signal'])
        else:
            features.append(0.0)
        
        if indicators.get('volume') and indicators.get('Volume_SMA') and indicators['Volume_SMA'] > 0:
            features.append(indicators['volume'] / indicators['Volume_SMA'])
        else:
            features.append(1.0)
        
        # Add trend context features (duration, slope, divergence)
        trend_context = indicators.get('trend_context', {})
        
        # RSI trend features
        rsi_ctx = trend_context.get('RSI', {})
        features.append(float(rsi_ctx.get('duration_candles', 0)))
        features.append(float(rsi_ctx.get('slope', 0.0)))
        divergence = rsi_ctx.get('divergence', 'none')
        features.append(1.0 if divergence == 'bullish' else -1.0 if divergence == 'bearish' else 0.0)
        
        # Stochastic trend features
        stoch_ctx = trend_context.get('Stochastic', {})
        features.append(float(stoch_ctx.get('duration_candles', 0)))
        features.append(float(stoch_ctx.get('slope', 0.0)))
        divergence = stoch_ctx.get('divergence', 'none')
        features.append(1.0 if divergence == 'bullish' else -1.0 if divergence == 'bearish' else 0.0)
        
        # MFI trend features
        mfi_ctx = trend_context.get('MFI', {})
        features.append(float(mfi_ctx.get('duration_candles', 0)))
        features.append(float(mfi_ctx.get('slope', 0.0)))
        divergence = mfi_ctx.get('divergence', 'none')
        features.append(1.0 if divergence == 'bullish' else -1.0 if divergence == 'bearish' else 0.0)
        
        # OBV trend features (volume-based, no duration tracking)
        obv_ctx = trend_context.get('OBV', {})
        features.append(float(obv_ctx.get('slope', 0.0)))
        divergence = obv_ctx.get('divergence', 'none')
        features.append(1.0 if divergence == 'bullish' else -1.0 if divergence == 'bearish' else 0.0)
        
        self.feature_columns = feature_names + [
            'price_vs_sma20', 'price_vs_sma50', 'macd_divergence', 'volume_ratio',
            'rsi_duration', 'rsi_slope', 'rsi_divergence',
            'stoch_duration', 'stoch_slope', 'stoch_divergence',
            'mfi_duration', 'mfi_slope', 'mfi_divergence',
            'obv_slope', 'obv_divergence'
        ]
        
        return np.array(features).reshape(1, -1)
    
    def train_models(self, min_trades=30):
        session = get_session()
        
        try:
            trades = session.query(Trade).filter(
                Trade.exit_price.isnot(None),
                Trade.outcome.isnot(None)
            ).all()
            
            if len(trades) < min_trades:
                print(f"Not enough trades for training. Need {min_trades}, have {len(trades)}")
                return False
            
            X = []
            y = []
            
            for trade in trades:
                if trade.indicators_at_entry:
                    features = self.prepare_features(trade.indicators_at_entry)
                    X.append(features.flatten())
                    y.append(1 if trade.outcome == 'win' else 0)
            
            if len(X) < min_trades:
                print("Not enough valid feature data")
                return False
            
            X = np.array(X)
            y = np.array(y)
            
            X_scaled = self.scaler.fit_transform(X)
            
            X_train, X_test, y_train, y_test = train_test_split(
                X_scaled, y, test_size=0.2, random_state=42, stratify=y if len(np.unique(y)) > 1 else None
            )
            
            self.rf_model = RandomForestClassifier(
                n_estimators=100,
                max_depth=10,
                min_samples_split=5,
                min_samples_leaf=2,
                random_state=42,
                class_weight='balanced'
            )
            self.rf_model.fit(X_train, y_train)
            
            self.xgb_model = XGBClassifier(
                n_estimators=100,
                max_depth=6,
                learning_rate=0.1,
                random_state=42,
                eval_metric='logloss'
            )
            self.xgb_model.fit(X_train, y_train)
            
            rf_pred = self.rf_model.predict(X_test)
            xgb_pred = self.xgb_model.predict(X_test)
            
            rf_metrics = {
                'accuracy': accuracy_score(y_test, rf_pred),
                'precision': precision_score(y_test, rf_pred, zero_division=0),
                'recall': recall_score(y_test, rf_pred, zero_division=0),
                'f1': f1_score(y_test, rf_pred, zero_division=0)
            }
            
            xgb_metrics = {
                'accuracy': accuracy_score(y_test, xgb_pred),
                'precision': precision_score(y_test, xgb_pred, zero_division=0),
                'recall': recall_score(y_test, xgb_pred, zero_division=0),
                'f1': f1_score(y_test, xgb_pred, zero_division=0)
            }
            
            self._save_models()
            self._save_performance_metrics('RandomForest', rf_metrics, len(trades))
            self._save_performance_metrics('XGBoost', xgb_metrics, len(trades))
            
            print(f"Models trained successfully on {len(trades)} trades")
            print(f"RF Accuracy: {rf_metrics['accuracy']:.2%}, XGB Accuracy: {xgb_metrics['accuracy']:.2%}")
            
            return True
            
        except Exception as e:
            print(f"Error training models: {e}")
            return False
        finally:
            session.close()
    
    def predict(self, indicators):
        models_available = False
        if self.rf_model is None or self.xgb_model is None:
            models_available = self._load_models()
        else:
            models_available = True
        
        rule_based_result = self._rule_based_prediction(indicators)
        
        if not models_available:
            return rule_based_result
        
        try:
            features = self.prepare_features(indicators)
            
            # Feature dimension compatibility check
            expected_features = self.scaler.n_features_in_ if hasattr(self.scaler, 'n_features_in_') else None
            actual_features = features.shape[1]
            
            if expected_features and expected_features != actual_features:
                print(f"‚ö†Ô∏è  Model dimension mismatch: Expected {expected_features} features, got {actual_features}")
                print(f"   Models were trained with old feature set - invalidating and using rule-based prediction")
                print(f"   System will retrain automatically when enough new trades accumulate (30+ trades needed)")
                
                # Invalidate old models and reinitialize scaler for future training
                self.rf_model = None
                self.xgb_model = None
                self.scaler = StandardScaler()  # Fresh scaler for retraining with new features
                
                # Delete old model files
                import os
                for file in ['rf_model.pkl', 'xgb_model.pkl', 'scaler.pkl']:
                    filepath = f'{self.model_dir}/{file}'
                    if os.path.exists(filepath):
                        os.remove(filepath)
                        print(f"   Deleted outdated model: {file}")
                
                return rule_based_result
            
            features_scaled = self.scaler.transform(features)
            
            rf_proba = self.rf_model.predict_proba(features_scaled)[0]
            xgb_proba = self.xgb_model.predict_proba(features_scaled)[0]
            
            ensemble_proba = (rf_proba + xgb_proba) / 2
            ml_win_probability = ensemble_proba[1]
            
            rule_score = rule_based_result['bullish_score'] - rule_based_result['bearish_score']
            rule_normalized = (rule_score + 20) / 40
            rule_normalized = max(0, min(1, rule_normalized))
            
            final_probability = (ml_win_probability * 0.7) + (rule_normalized * 0.3)
            
            current_price = indicators.get('current_price', 0)
            atr = indicators.get('ATR', current_price * 0.02)
            min_distance = max(atr, current_price * 0.002)
            
            reasons = rule_based_result.get('reasons', [])
            
            if final_probability > 0.6:
                signal = 'LONG'
                entry_price = current_price
                stop_loss = current_price - (2 * min_distance)
                take_profit = current_price + (3 * min_distance)
                recommendation = f"Strong LONG signal. Enter at {entry_price:.2f}"
                reasons.append(f"ML models: {ml_win_probability*100:.1f}%, Weighted rules: {rule_normalized*100:.1f}%, Final: {final_probability*100:.1f}%")
            elif final_probability < 0.4:
                signal = 'SHORT'
                entry_price = current_price
                stop_loss = current_price + (2 * min_distance)
                take_profit = current_price - (3 * min_distance)
                recommendation = f"Strong SHORT signal. Enter at {entry_price:.2f}"
                reasons.append(f"ML models: {(1-ml_win_probability)*100:.1f}%, Weighted rules: {(1-rule_normalized)*100:.1f}%, Final: {(1-final_probability)*100:.1f}%")
            else:
                signal = 'HOLD'
                entry_price = None
                stop_loss = None
                take_profit = None
                recommendation = "No clear signal. Wait for better opportunity."
                reasons.append(f"Hybrid confidence below threshold (final: {final_probability*100:.1f}%)")
            
            return {
                'signal': signal,
                'confidence': round(max(final_probability, 1 - final_probability) * 100, 2),
                'win_probability': round(final_probability * 100, 2),
                'recommendation': recommendation,
                'entry_price': round(entry_price, 2) if entry_price else None,
                'stop_loss': round(stop_loss, 2) if stop_loss else None,
                'take_profit': round(take_profit, 2) if take_profit else None,
                'rf_confidence': round(rf_proba[1] * 100, 2),
                'xgb_confidence': round(xgb_proba[1] * 100, 2),
                'ml_probability': round(ml_win_probability * 100, 2),
                'rule_probability': round(rule_normalized * 100, 2),
                'method': 'hybrid',
                'reasons': reasons
            }
            
        except Exception as e:
            print(f"Prediction error: {e}")
            return {
                'signal': 'HOLD',
                'confidence': 0.0,
                'recommendation': f'Error making prediction: {str(e)}',
                'entry_price': None,
                'stop_loss': None,
                'take_profit': None
            }
    
    def _save_models(self):
        try:
            joblib.dump(self.rf_model, f'{self.model_dir}/rf_model.pkl')
            joblib.dump(self.xgb_model, f'{self.model_dir}/xgb_model.pkl')
            joblib.dump(self.scaler, f'{self.model_dir}/scaler.pkl')
            print("Models saved successfully")
        except Exception as e:
            print(f"Error saving models: {e}")
    
    def _load_models(self):
        try:
            if os.path.exists(f'{self.model_dir}/rf_model.pkl'):
                self.rf_model = joblib.load(f'{self.model_dir}/rf_model.pkl')
                self.xgb_model = joblib.load(f'{self.model_dir}/xgb_model.pkl')
                self.scaler = joblib.load(f'{self.model_dir}/scaler.pkl')
                print("Models loaded successfully")
                return True
            return False
        except Exception as e:
            print(f"Error loading models: {e}")
            return False
    
    def _rule_based_prediction(self, indicators):
        """
        Rule-based prediction using technical indicators.
        Always makes a prediction even without ML models.
        Learning happens AFTER trades are executed.
        """
        current_price = indicators.get('current_price', 0)
        atr = indicators.get('ATR', current_price * 0.02)
        min_distance = max(atr, current_price * 0.002)
        
        bullish_signals = 0
        bearish_signals = 0
        reasons = []
        
        rsi_weight = self.indicator_weights.get('RSI', 2.0)
        
        # Get trend context for duration-aware signals
        trend_context = indicators.get('trend_context', {})
        rsi_ctx = trend_context.get('RSI', {})
        
        rsi = indicators.get('RSI')
        if rsi:
            duration = rsi_ctx.get('duration_candles', 0)
            slope = rsi_ctx.get('slope', 0.0)
            divergence = rsi_ctx.get('divergence', 'none')
            
            if rsi < 30:
                base_signal = 2 * rsi_weight
                # Duration bonus: longer oversold = stronger reversal signal
                duration_bonus = min(2.0, duration / 10) if duration > 10 else 0
                # Momentum bonus: rising while oversold = bullish
                momentum_bonus = 1.0 if slope > 0.5 else 0
                # Divergence bonus
                divergence_bonus = 1.5 if divergence == 'bullish' else 0
                
                total_signal = base_signal + duration_bonus + momentum_bonus + divergence_bonus
                bullish_signals += total_signal
                
                context_info = []
                if duration > 10:
                    context_info.append(f"{duration} candles")
                if slope > 0.5:
                    context_info.append("rising momentum")
                if divergence == 'bullish':
                    context_info.append("bullish divergence")
                
                reason = f"RSI oversold ({rsi:.1f})"
                if context_info:
                    reason += f" [{', '.join(context_info)}]"
                reason += f" - strong buy signal (weight: {rsi_weight:.1f}x + {total_signal - base_signal:.1f} bonus)"
                reasons.append(reason)
                
            elif rsi < 40:
                bullish_signals += 1 * rsi_weight
                reasons.append(f"RSI below 40 ({rsi:.1f}) - buy signal (weight: {rsi_weight:.1f}x)")
                
            elif rsi > 70:
                base_signal = 2 * rsi_weight
                # Duration bonus: longer overbought = stronger reversal signal
                duration_bonus = min(2.0, duration / 10) if duration > 10 else 0
                # Momentum bonus: falling while overbought = bearish
                momentum_bonus = 1.0 if slope < -0.5 else 0
                # Divergence bonus
                divergence_bonus = 1.5 if divergence == 'bearish' else 0
                
                total_signal = base_signal + duration_bonus + momentum_bonus + divergence_bonus
                bearish_signals += total_signal
                
                context_info = []
                if duration > 10:
                    context_info.append(f"{duration} candles")
                if slope < -0.5:
                    context_info.append("falling momentum")
                if divergence == 'bearish':
                    context_info.append("bearish divergence")
                
                reason = f"RSI overbought ({rsi:.1f})"
                if context_info:
                    reason += f" [{', '.join(context_info)}]"
                reason += f" - strong sell signal (weight: {rsi_weight:.1f}x + {total_signal - base_signal:.1f} bonus)"
                reasons.append(reason)
                
            elif rsi > 60:
                bearish_signals += 1 * rsi_weight
                reasons.append(f"RSI above 60 ({rsi:.1f}) - sell signal (weight: {rsi_weight:.1f}x)")
        
        macd_weight = self.indicator_weights.get('MACD', 2.0)
        
        macd = indicators.get('MACD')
        macd_signal = indicators.get('MACD_signal')
        if macd and macd_signal:
            if macd > macd_signal:
                bullish_signals += 2 * macd_weight
                reasons.append(f"MACD bullish crossover (weight: {macd_weight:.1f}x)")
            else:
                bearish_signals += 2 * macd_weight
                reasons.append(f"MACD bearish crossover (weight: {macd_weight:.1f}x)")
        
        stoch_weight = self.indicator_weights.get('Stoch_K', 1.0)
        stoch_ctx = trend_context.get('Stochastic', {})
        
        stoch_k = indicators.get('Stoch_K')
        if stoch_k:
            duration = stoch_ctx.get('duration_candles', 0)
            slope = stoch_ctx.get('slope', 0.0)
            divergence = stoch_ctx.get('divergence', 'none')
            
            if stoch_k < 20:
                base_signal = 1 * stoch_weight
                duration_bonus = min(1.0, duration / 15) if duration > 10 else 0
                momentum_bonus = 0.5 if slope > 0.5 else 0
                divergence_bonus = 1.0 if divergence == 'bullish' else 0
                
                total_signal = base_signal + duration_bonus + momentum_bonus + divergence_bonus
                bullish_signals += total_signal
                
                context_info = []
                if duration > 10:
                    context_info.append(f"{duration} candles")
                if slope > 0.5:
                    context_info.append("rising")
                if divergence == 'bullish':
                    context_info.append("bullish div")
                
                reason = f"Stochastic oversold ({stoch_k:.1f})"
                if context_info:
                    reason += f" [{', '.join(context_info)}]"
                reason += f" (weight: {stoch_weight:.1f}x + {total_signal - base_signal:.1f} bonus)"
                reasons.append(reason)
                
            elif stoch_k > 80:
                base_signal = 1 * stoch_weight
                duration_bonus = min(1.0, duration / 15) if duration > 10 else 0
                momentum_bonus = 0.5 if slope < -0.5 else 0
                divergence_bonus = 1.0 if divergence == 'bearish' else 0
                
                total_signal = base_signal + duration_bonus + momentum_bonus + divergence_bonus
                bearish_signals += total_signal
                
                context_info = []
                if duration > 10:
                    context_info.append(f"{duration} candles")
                if slope < -0.5:
                    context_info.append("falling")
                if divergence == 'bearish':
                    context_info.append("bearish div")
                
                reason = f"Stochastic overbought ({stoch_k:.1f})"
                if context_info:
                    reason += f" [{', '.join(context_info)}]"
                reason += f" (weight: {stoch_weight:.1f}x + {total_signal - base_signal:.1f} bonus)"
                reasons.append(reason)
        
        adx_weight = self.indicator_weights.get('ADX', 2.0)
        
        adx = indicators.get('ADX')
        di_plus = indicators.get('DI_plus', 0)
        di_minus = indicators.get('DI_minus', 0)
        if adx and adx > 25:
            if di_plus > di_minus:
                bullish_signals += 2 * adx_weight
                reasons.append(f"Strong uptrend (ADX {adx:.1f}, +DI > -DI, weight: {adx_weight:.1f}x)")
            else:
                bearish_signals += 2 * adx_weight
                reasons.append(f"Strong downtrend (ADX {adx:.1f}, -DI > +DI, weight: {adx_weight:.1f}x)")
        
        sma_weight = self.indicator_weights.get('SMA', 1.0)
        
        price = indicators.get('current_price', 0)
        sma_20 = indicators.get('SMA_20')
        sma_50 = indicators.get('SMA_50')
        if price and sma_20:
            if price > sma_20:
                bullish_signals += 1 * sma_weight
                reasons.append(f"Price above SMA 20 (weight: {sma_weight:.1f}x)")
            else:
                bearish_signals += 1 * sma_weight
                reasons.append(f"Price below SMA 20 (weight: {sma_weight:.1f}x)")
        
        if price and sma_50:
            if price > sma_50:
                bullish_signals += 1 * sma_weight
                reasons.append(f"Price above SMA 50 (weight: {sma_weight:.1f}x)")
            else:
                bearish_signals += 1 * sma_weight
                reasons.append(f"Price below SMA 50 (weight: {sma_weight:.1f}x)")
        
        mfi_weight = self.indicator_weights.get('MFI', 1.0)
        mfi_ctx = trend_context.get('MFI', {})
        
        mfi = indicators.get('MFI')
        if mfi:
            duration = mfi_ctx.get('duration_candles', 0)
            slope = mfi_ctx.get('slope', 0.0)
            divergence = mfi_ctx.get('divergence', 'none')
            
            if mfi < 20:
                base_signal = 1 * mfi_weight
                duration_bonus = min(1.0, duration / 15) if duration > 10 else 0
                momentum_bonus = 0.5 if slope > 0.5 else 0
                divergence_bonus = 1.0 if divergence == 'bullish' else 0
                
                total_signal = base_signal + duration_bonus + momentum_bonus + divergence_bonus
                bullish_signals += total_signal
                
                context_info = []
                if duration > 10:
                    context_info.append(f"{duration} candles")
                if slope > 0.5:
                    context_info.append("rising")
                if divergence == 'bullish':
                    context_info.append("bullish div")
                
                reason = f"MFI oversold ({mfi:.1f})"
                if context_info:
                    reason += f" [{', '.join(context_info)}]"
                reason += f" (weight: {mfi_weight:.1f}x + {total_signal - base_signal:.1f} bonus)"
                reasons.append(reason)
                
            elif mfi > 80:
                base_signal = 1 * mfi_weight
                duration_bonus = min(1.0, duration / 15) if duration > 10 else 0
                momentum_bonus = 0.5 if slope < -0.5 else 0
                divergence_bonus = 1.0 if divergence == 'bearish' else 0
                
                total_signal = base_signal + duration_bonus + momentum_bonus + divergence_bonus
                bearish_signals += total_signal
                
                context_info = []
                if duration > 10:
                    context_info.append(f"{duration} candles")
                if slope < -0.5:
                    context_info.append("falling")
                if divergence == 'bearish':
                    context_info.append("bearish div")
                
                reason = f"MFI overbought ({mfi:.1f})"
                if context_info:
                    reason += f" [{', '.join(context_info)}]"
                reason += f" (weight: {mfi_weight:.1f}x + {total_signal - base_signal:.1f} bonus)"
                reasons.append(reason)
        
        # OBV Divergence Analysis (Volume-based)
        obv_ctx = trend_context.get('OBV', {})
        obv_divergence = obv_ctx.get('divergence', 'none')
        obv_slope = obv_ctx.get('slope', 0.0)
        
        if obv_divergence == 'bullish':
            # Price falling but volume accumulating = smart money buying
            divergence_signal = 2.5
            bullish_signals += divergence_signal
            slope_info = "accumulation" if obv_slope > 0 else ""
            reason = f"Bullish OBV divergence detected - smart money accumulating"
            if slope_info:
                reason += f" [{slope_info}]"
            reasons.append(reason + f" (+{divergence_signal:.1f} signal)")
            
        elif obv_divergence == 'bearish':
            # Price rising but volume distributing = smart money selling
            divergence_signal = 2.5
            bearish_signals += divergence_signal
            slope_info = "distribution" if obv_slope < 0 else ""
            reason = f"Bearish OBV divergence detected - smart money distributing"
            if slope_info:
                reason += f" [{slope_info}]"
            reasons.append(reason + f" (+{divergence_signal:.1f} signal)")
        
        total_signals = bullish_signals + bearish_signals
        if total_signals == 0:
            total_signals = 1
        
        if bullish_signals > bearish_signals * 1.5:
            signal = 'LONG'
            confidence = min(95, (bullish_signals / total_signals) * 100)
            entry_price = current_price
            stop_loss = current_price - (2 * min_distance)
            take_profit = current_price + (3 * min_distance)
            recommendation = f"Rule-based LONG signal (no ML training yet)"
        elif bearish_signals > bullish_signals * 1.5:
            signal = 'SHORT'
            confidence = min(95, (bearish_signals / total_signals) * 100)
            entry_price = current_price
            stop_loss = current_price + (2 * min_distance)
            take_profit = current_price - (3 * min_distance)
            recommendation = f"Rule-based SHORT signal (no ML training yet)"
        else:
            signal = 'HOLD'
            confidence = abs(bullish_signals - bearish_signals) / total_signals * 100
            entry_price = None
            stop_loss = None
            take_profit = None
            recommendation = "Mixed signals - wait for clearer setup"
            reasons.append(f"Bullish: {bullish_signals}, Bearish: {bearish_signals} - too close")
        
        return {
            'signal': signal,
            'confidence': round(confidence, 1),
            'recommendation': recommendation,
            'entry_price': round(entry_price, 2) if entry_price else None,
            'stop_loss': round(stop_loss, 2) if stop_loss else None,
            'take_profit': round(take_profit, 2) if take_profit else None,
            'reasons': reasons,
            'method': 'rule_based',
            'bullish_score': bullish_signals,
            'bearish_score': bearish_signals
        }
    
    def _save_performance_metrics(self, model_name, metrics, total_trades):
        session = get_session()
        
        try:
            session.query(ModelPerformance).filter(
                ModelPerformance.model_name == model_name
            ).update({'is_active': False})
            
            perf = ModelPerformance(
                model_name=model_name,
                version='1.0',
                accuracy=metrics['accuracy'],
                precision=metrics['precision'],
                recall=metrics['recall'],
                f1_score=metrics['f1'],
                total_trades=total_trades,
                is_active=True
            )
            
            session.add(perf)
            session.commit()
            
        except Exception as e:
            print(f"Error saving performance metrics: {e}")
            session.rollback()
        finally:
            session.close()
    
    def learn_from_trade(self, trade_id):
        """
        Learn from a single completed trade immediately.
        Called after every trade closes - THIS IS WHERE LEARNING HAPPENS!
        """
        session = get_session()
        
        try:
            trade = session.query(Trade).filter(Trade.id == trade_id).first()
            
            if not trade or not trade.exit_price or not trade.outcome:
                return False
            
            print(f"\nüìö Learning from trade #{trade_id}:")
            print(f"   Direction: {trade.direction}, Outcome: {trade.outcome}")
            print(f"   P&L: ${trade.profit_loss:.2f}")
            
            if trade.indicators_at_entry:
                self._learn_from_single_trade(trade)
            
            total_trades = session.query(Trade).filter(
                Trade.exit_price.isnot(None),
                Trade.outcome.isnot(None)
            ).count()
            
            print(f"   Total completed trades: {total_trades}")
            
            if total_trades % 30 == 0 and total_trades >= 30:
                print(f"\nüéØ Milestone reached: {total_trades} trades!")
                print("   Triggering comprehensive batch analysis...")
                self.batch_analysis()
            elif total_trades >= 10:
                print(f"   Quick retrain with {total_trades} trades...")
                self.train_models(min_trades=10)
            
            return True
            
        except Exception as e:
            print(f"Error learning from trade: {e}")
            return False
        finally:
            session.close()
    
    def _learn_from_single_trade(self, trade):
        """
        Immediately update indicator weights based on this single trade.
        This makes the system learn from EVERY trade, not just batches.
        """
        is_win = trade.outcome == 'win'
        indicators = trade.indicators_at_entry
        
        print(f"   üß† Updating weights based on this trade...")
        
        learning_rate = 0.05
        
        for ind_name in ['RSI', 'MACD', 'ADX', 'Stoch_K', 'MFI', 'SMA', 'CCI']:
            if ind_name in indicators and indicators[ind_name] is not None:
                current_weight = self.indicator_weights.get(ind_name, 1.0)
                
                if is_win:
                    new_weight = min(3.0, current_weight * (1 + learning_rate))
                    print(f"   ‚¨ÜÔ∏è {ind_name}: {current_weight:.2f} ‚Üí {new_weight:.2f} (win)")
                else:
                    new_weight = max(0.5, current_weight * (1 - learning_rate))
                    print(f"   ‚¨áÔ∏è {ind_name}: {current_weight:.2f} ‚Üí {new_weight:.2f} (loss)")
                
                self.indicator_weights[ind_name] = new_weight
        
        price = indicators.get('current_price', 0)
        sma_20 = indicators.get('SMA_20')
        sma_50 = indicators.get('SMA_50')
        if (sma_20 or sma_50) and 'SMA' not in indicators:
            current_weight = self.indicator_weights.get('SMA', 1.0)
            if is_win:
                new_weight = min(3.0, current_weight * (1 + learning_rate))
                print(f"   ‚¨ÜÔ∏è SMA: {current_weight:.2f} ‚Üí {new_weight:.2f} (win)")
            else:
                new_weight = max(0.5, current_weight * (1 - learning_rate))
                print(f"   ‚¨áÔ∏è SMA: {current_weight:.2f} ‚Üí {new_weight:.2f} (loss)")
            self.indicator_weights['SMA'] = new_weight
        
        self._save_indicator_weights()
        print(f"   üíæ Updated weights saved - System is now smarter!")
        
        # Track per-indicator performance
        self._track_indicator_performance(trade)
    
    def _track_indicator_performance(self, trade):
        """
        Track which specific indicators were correct/wrong for this trade.
        Updates the IndicatorPerformance table in the database.
        """
        session = get_session()
        
        try:
            is_win = trade.outcome == 'win'
            trade_direction = trade.trade_type
            indicators = trade.indicators_at_entry
            
            if not indicators:
                return
            
            # Analyze each indicator's signal
            indicator_signals = self._evaluate_indicator_signals(indicators, trade_direction)
            
            # Update database for each indicator
            for ind_name, signal in indicator_signals.items():
                # Skip neutral signals - they don't count for accuracy
                if signal == 'neutral':
                    continue
                
                # Get or create indicator performance record
                ind_perf = session.query(IndicatorPerformance).filter(
                    IndicatorPerformance.indicator_name == ind_name
                ).first()
                
                if not ind_perf:
                    ind_perf = IndicatorPerformance(
                        indicator_name=ind_name,
                        correct_count=0,
                        wrong_count=0,
                        total_signals=0,
                        accuracy_rate=0.0,
                        weight_multiplier=self.indicator_weights.get(ind_name, 1.0)
                    )
                    session.add(ind_perf)
                
                # Update counts - properly account for trade direction and signal
                ind_perf.total_signals += 1
                
                # Determine if indicator was correct based on trade direction, signal, and outcome
                # For LONG trades: bullish signal + win = correct, bearish signal + loss = correct
                # For SHORT trades: bearish signal + win = correct, bullish signal + loss = correct
                is_long = trade_direction == 'LONG'
                is_bullish_signal = signal == 'bullish'
                indicator_was_correct = False
                
                if is_long:
                    # LONG trade: bullish signal should win, bearish signal means loss expected
                    if (is_bullish_signal and is_win) or (not is_bullish_signal and not is_win):
                        indicator_was_correct = True
                else:
                    # SHORT trade: bearish signal should win, bullish signal means loss expected
                    if (not is_bullish_signal and is_win) or (is_bullish_signal and not is_win):
                        indicator_was_correct = True
                
                if indicator_was_correct:
                    ind_perf.correct_count += 1
                else:
                    ind_perf.wrong_count += 1
                
                # Recalculate accuracy
                ind_perf.accuracy_rate = (ind_perf.correct_count / ind_perf.total_signals * 100) if ind_perf.total_signals > 0 else 0.0
                ind_perf.weight_multiplier = self.indicator_weights.get(ind_name, 1.0)
                ind_perf.last_updated = datetime.utcnow()
            
            session.commit()
            
        except Exception as e:
            print(f"   Error tracking indicator performance: {e}")
            session.rollback()
        finally:
            session.close()
    
    def _evaluate_indicator_signals(self, indicators, trade_direction):
        """
        Evaluate which signal each indicator gave (bullish/bearish/neutral).
        Returns dict of {indicator_name: 'bullish'|'bearish'|'neutral'}
        """
        signals = {}
        
        # RSI
        rsi = indicators.get('RSI')
        if rsi is not None:
            if rsi < 30:
                signals['RSI'] = 'bullish'  # Oversold
            elif rsi > 70:
                signals['RSI'] = 'bearish'  # Overbought
            else:
                signals['RSI'] = 'neutral'
        
        # MACD
        macd = indicators.get('MACD')
        macd_signal = indicators.get('MACD_signal')
        if macd is not None and macd_signal is not None:
            if macd > macd_signal:
                signals['MACD'] = 'bullish'
            elif macd < macd_signal:
                signals['MACD'] = 'bearish'
            else:
                signals['MACD'] = 'neutral'
        
        # Stochastic
        stoch_k = indicators.get('Stoch_K')
        if stoch_k is not None:
            if stoch_k < 20:
                signals['Stochastic'] = 'bullish'  # Oversold
            elif stoch_k > 80:
                signals['Stochastic'] = 'bearish'  # Overbought
            else:
                signals['Stochastic'] = 'neutral'
        
        # ADX (trend strength, not direction - use DI)
        adx = indicators.get('ADX')
        di_plus = indicators.get('DI_plus')
        di_minus = indicators.get('DI_minus')
        if di_plus is not None and di_minus is not None and adx is not None:
            if adx < 25:
                signals['ADX'] = 'neutral'  # Weak trend
            elif di_plus > di_minus:
                signals['ADX'] = 'bullish'
            else:
                signals['ADX'] = 'bearish'
        
        # MFI
        mfi = indicators.get('MFI')
        if mfi is not None:
            if mfi < 20:
                signals['MFI'] = 'bullish'  # Oversold
            elif mfi > 80:
                signals['MFI'] = 'bearish'  # Overbought
            else:
                signals['MFI'] = 'neutral'
        
        # CCI
        cci = indicators.get('CCI')
        if cci is not None:
            if cci < -100:
                signals['CCI'] = 'bullish'  # Oversold
            elif cci > 100:
                signals['CCI'] = 'bearish'  # Overbought
            else:
                signals['CCI'] = 'neutral'
        
        # OBV (volume flow)
        obv = indicators.get('OBV')
        if obv is not None:
            # Simplified: positive OBV suggests accumulation (bullish)
            if obv > 0:
                signals['OBV'] = 'bullish'
            elif obv < 0:
                signals['OBV'] = 'bearish'
            else:
                signals['OBV'] = 'neutral'
        
        return signals
    
    def batch_analysis(self):
        """
        Comprehensive analysis every 30 trades.
        Analyzes wins vs losses, indicator performance, and improves predictions.
        """
        session = get_session()
        
        try:
            trades = session.query(Trade).filter(
                Trade.exit_price.isnot(None),
                Trade.outcome.isnot(None)
            ).all()
            
            if len(trades) < 30:
                print(f"Not enough trades for batch analysis. Need 30, have {len(trades)}")
                return
            
            total_trades = len(trades)
            wins = [t for t in trades if t.outcome == 'win']
            losses = [t for t in trades if t.outcome == 'loss']
            
            win_rate = (len(wins) / total_trades) * 100 if total_trades > 0 else 0
            
            print(f"\n{'='*60}")
            print(f"üìä BATCH ANALYSIS - {total_trades} Trades")
            print(f"{'='*60}")
            print(f"\n‚úÖ Wins: {len(wins)} ({len(wins)/total_trades*100:.1f}%)")
            print(f"‚ùå Losses: {len(losses)} ({len(losses)/total_trades*100:.1f}%)")
            print(f"üéØ Overall Win Rate: {win_rate:.1f}%")
            
            total_pnl = sum(t.profit_loss for t in trades if t.profit_loss)
            avg_win = sum(t.profit_loss for t in wins if t.profit_loss) / len(wins) if wins else 0
            avg_loss = sum(t.profit_loss for t in losses if t.profit_loss) / len(losses) if losses else 0
            
            print(f"\nüí∞ P&L Analysis:")
            print(f"   Total P&L: ${total_pnl:.2f}")
            print(f"   Avg Win: ${avg_win:.2f}")
            print(f"   Avg Loss: ${avg_loss:.2f}")
            print(f"   Risk/Reward: {abs(avg_win/avg_loss):.2f}" if avg_loss != 0 else "   Risk/Reward: N/A")
            
            indicator_performance = self._analyze_indicator_performance(wins, losses)
            
            print(f"\nüìà Indicator Performance Analysis:")
            for indicator, stats in indicator_performance.items():
                if stats['count'] > 5:
                    print(f"   {indicator}: {stats['win_rate']:.1f}% win rate ({stats['wins']}/{stats['count']} trades)")
            
            print(f"\nüîç What Led to Wins:")
            self._analyze_winning_patterns(wins)
            
            print(f"\n‚ö†Ô∏è  What Led to Losses:")
            self._analyze_losing_patterns(losses)
            
            self._update_indicator_weights(indicator_performance)
            
            print(f"\nü§ñ Retraining ML models with all {total_trades} trades...")
            success = self.train_models(min_trades=30)
            
            if success:
                print(f"‚úÖ Models retrained successfully!")
                print(f"   System is now smarter based on {total_trades} trades of experience!")
            
            print(f"\n{'='*60}\n")
            
        except Exception as e:
            print(f"Error in batch analysis: {e}")
            import traceback
            traceback.print_exc()
        finally:
            session.close()
    
    def _analyze_indicator_performance(self, wins, losses):
        """Analyze which indicators performed best in winning trades"""
        performance = {}
        
        all_trades = wins + losses
        
        for trade in all_trades:
            if not trade.indicators_at_entry:
                continue
            
            indicators = trade.indicators_at_entry
            is_win = trade.outcome == 'win'
            
            for ind_name in ['RSI', 'MACD', 'ADX', 'MFI', 'CCI', 'Stoch_K', 'SMA']:
                if ind_name not in performance:
                    performance[ind_name] = {'wins': 0, 'count': 0, 'win_rate': 0}
                
                if ind_name in indicators and indicators[ind_name] is not None:
                    performance[ind_name]['count'] += 1
                    if is_win:
                        performance[ind_name]['wins'] += 1
                elif ind_name == 'SMA' and (indicators.get('SMA_20') or indicators.get('SMA_50')):
                    performance['SMA']['count'] += 1
                    if is_win:
                        performance['SMA']['wins'] += 1
        
        for ind_name in performance:
            if performance[ind_name]['count'] > 0:
                performance[ind_name]['win_rate'] = (performance[ind_name]['wins'] / performance[ind_name]['count']) * 100
        
        return performance
    
    def _analyze_winning_patterns(self, wins):
        """Identify common patterns in winning trades"""
        if not wins:
            return
        
        rsi_oversold_wins = 0
        rsi_overbought_wins = 0
        macd_bullish_wins = 0
        strong_trend_wins = 0
        
        for trade in wins:
            if not trade.indicators_at_entry:
                continue
            
            ind = trade.indicators_at_entry
            
            if ind.get('RSI'):
                if ind['RSI'] < 30 and trade.direction == 'LONG':
                    rsi_oversold_wins += 1
                elif ind['RSI'] > 70 and trade.direction == 'SHORT':
                    rsi_overbought_wins += 1
            
            if ind.get('MACD') and ind.get('MACD_signal'):
                if ind['MACD'] > ind['MACD_signal'] and trade.direction == 'LONG':
                    macd_bullish_wins += 1
            
            if ind.get('ADX') and ind['ADX'] > 25:
                strong_trend_wins += 1
        
        total = len(wins)
        print(f"   - RSI oversold + LONG: {rsi_oversold_wins}/{total} ({rsi_oversold_wins/total*100:.1f}%)")
        print(f"   - RSI overbought + SHORT: {rsi_overbought_wins}/{total} ({rsi_overbought_wins/total*100:.1f}%)")
        print(f"   - MACD bullish + LONG: {macd_bullish_wins}/{total} ({macd_bullish_wins/total*100:.1f}%)")
        print(f"   - Strong trend (ADX>25): {strong_trend_wins}/{total} ({strong_trend_wins/total*100:.1f}%)")
    
    def _analyze_losing_patterns(self, losses):
        """Identify what was missed in losing trades"""
        if not losses:
            return
        
        weak_trend_losses = 0
        mixed_signals_losses = 0
        
        for trade in losses:
            if not trade.indicators_at_entry:
                continue
            
            ind = trade.indicators_at_entry
            
            if ind.get('ADX') and ind['ADX'] < 20:
                weak_trend_losses += 1
            
            rsi = ind.get('RSI')
            macd = ind.get('MACD')
            macd_sig = ind.get('MACD_signal')
            
            if rsi and macd and macd_sig:
                rsi_signal = 'bullish' if rsi < 50 else 'bearish'
                macd_signal = 'bullish' if macd > macd_sig else 'bearish'
                
                if rsi_signal != macd_signal:
                    mixed_signals_losses += 1
        
        total = len(losses)
        print(f"   - Weak trend (ADX<20): {weak_trend_losses}/{total} ({weak_trend_losses/total*100:.1f}%)")
        print(f"   - Mixed RSI/MACD signals: {mixed_signals_losses}/{total} ({mixed_signals_losses/total*100:.1f}%)")
        print(f"   üí° Lesson: Avoid trading when trend is weak or indicators conflict")
    
    def _update_indicator_weights(self, indicator_performance):
        """
        Update indicator weights based on performance.
        Better performing indicators get higher weights in future predictions.
        """
        print(f"\nüîÑ Updating indicator weights based on performance...")
        
        for indicator, stats in indicator_performance.items():
            if stats['count'] < 5:
                continue
            
            win_rate = stats['win_rate']
            
            if win_rate > 70:
                self.indicator_weights[indicator] = min(3.0, self.indicator_weights.get(indicator, 1.0) * 1.2)
                print(f"   ‚¨ÜÔ∏è {indicator}: Increased weight to {self.indicator_weights[indicator]:.2f} (win rate: {win_rate:.1f}%)")
            elif win_rate < 40:
                self.indicator_weights[indicator] = max(0.5, self.indicator_weights.get(indicator, 1.0) * 0.8)
                print(f"   ‚¨áÔ∏è {indicator}: Decreased weight to {self.indicator_weights[indicator]:.2f} (win rate: {win_rate:.1f}%)")
            else:
                print(f"   ‚û°Ô∏è {indicator}: Weight unchanged at {self.indicator_weights.get(indicator, 1.0):.2f} (win rate: {win_rate:.1f}%)")
        
        self._save_indicator_weights()
    
    def _save_indicator_weights(self):
        """Save learned indicator weights to disk"""
        try:
            import json
            weights_file = f'{self.model_dir}/indicator_weights.json'
            with open(weights_file, 'w') as f:
                json.dump(self.indicator_weights, f)
            print(f"   üíæ Indicator weights saved")
        except Exception as e:
            print(f"   Error saving weights: {e}")
    
    def _load_indicator_weights(self):
        """Load learned indicator weights from disk"""
        try:
            import json
            weights_file = f'{self.model_dir}/indicator_weights.json'
            if os.path.exists(weights_file):
                with open(weights_file, 'r') as f:
                    loaded_weights = json.load(f)
                    self.indicator_weights.update(loaded_weights)
                print(f"üìÇ Loaded learned indicator weights from previous sessions")
        except Exception as e:
            pass


================================================================================
5. whale_tracker.py - WHALE DETECTION AND SMART MONEY ANALYSIS
================================================================================

import pandas as pd
import numpy as np
from datetime import datetime

class WhaleTracker:
    def __init__(self, df, orderbook_data=None):
        self.df = df.copy()
        self.orderbook_data = orderbook_data
        
    def detect_whale_movements(self, volume_threshold_multiplier=3.0):
        df = self.df.copy()
        
        if 'Volume_SMA' not in df.columns and len(df) >= 20:
            df['Volume_SMA'] = df['volume'].rolling(window=20).mean()
        
        whale_signals = []
        
        if 'Volume_SMA' in df.columns:
            df['volume_ratio'] = df['volume'] / df['Volume_SMA']
            
            recent_data = df.tail(50)
            
            for idx, row in recent_data.iterrows():
                if pd.notna(row['volume_ratio']) and row['volume_ratio'] > volume_threshold_multiplier:
                    price_change = ((row['close'] - row['open']) / row['open']) * 100
                    
                    impact_score = row['volume_ratio'] * abs(price_change)
                    
                    if row['close'] > row['open']:
                        transaction_type = 'BUY'
                    else:
                        transaction_type = 'SELL'
                    
                    whale_signals.append({
                        'timestamp': row['timestamp'],
                        'transaction_type': transaction_type,
                        'volume': row['volume'],
                        'volume_ratio': round(row['volume_ratio'], 2),
                        'price': row['close'],
                        'price_change_pct': round(price_change, 2),
                        'impact_score': round(impact_score, 2)
                    })
        
        return sorted(whale_signals, key=lambda x: x['impact_score'], reverse=True)[:10]
    
    def detect_smart_money(self):
        df = self.df.copy()
        signals = []
        
        if len(df) < 20:
            return signals
        
        recent = df.tail(20)
        
        avg_volume = recent['volume'].mean()
        current_volume = recent.iloc[-1]['volume']
        
        price_trend = 'up' if recent.iloc[-1]['close'] > recent.iloc[-10]['close'] else 'down'
        
        volume_trend = 'increasing' if current_volume > avg_volume * 1.5 else 'normal'
        
        if volume_trend == 'increasing':
            if price_trend == 'up':
                signals.append({
                    'type': 'accumulation',
                    'description': 'Smart money accumulation detected - Rising prices with high volume',
                    'confidence': 'high' if current_volume > avg_volume * 2 else 'medium',
                    'timestamp': recent.iloc[-1]['timestamp']
                })
            else:
                signals.append({
                    'type': 'distribution',
                    'description': 'Smart money distribution detected - Falling prices with high volume',
                    'confidence': 'high' if current_volume > avg_volume * 2 else 'medium',
                    'timestamp': recent.iloc[-1]['timestamp']
                })
        
        if self.orderbook_data:
            signals.extend(self._analyze_orderbook())
        
        return signals
    
    def _analyze_orderbook(self):
        signals = []
        
        if not self.orderbook_data or 'bids' not in self.orderbook_data or 'asks' not in self.orderbook_data:
            return signals
        
        bids = self.orderbook_data['bids']
        asks = self.orderbook_data['asks']
        
        if not bids or not asks:
            return signals
        
        total_bid_volume = sum([bid[1] for bid in bids[:10]])
        total_ask_volume = sum([ask[1] for ask in asks[:10]])
        
        if total_bid_volume > total_ask_volume * 1.5:
            signals.append({
                'type': 'buy_wall',
                'description': f'Strong buy wall detected - Bid volume {round(total_bid_volume/total_ask_volume, 2)}x ask volume',
                'confidence': 'high',
                'timestamp': datetime.utcnow()
            })
        elif total_ask_volume > total_bid_volume * 1.5:
            signals.append({
                'type': 'sell_wall',
                'description': f'Strong sell wall detected - Ask volume {round(total_ask_volume/total_bid_volume, 2)}x bid volume',
                'confidence': 'high',
                'timestamp': datetime.utcnow()
            })
        
        large_bids = [bid for bid in bids if bid[1] > total_bid_volume * 0.2]
        large_asks = [ask for ask in asks if ask[1] > total_ask_volume * 0.2]
        
        if large_bids:
            signals.append({
                'type': 'large_bid',
                'description': f'Large bid order detected at {large_bids[0][0]}',
                'confidence': 'medium',
                'timestamp': datetime.utcnow()
            })
        
        if large_asks:
            signals.append({
                'type': 'large_ask',
                'description': f'Large ask order detected at {large_asks[0][0]}',
                'confidence': 'medium',
                'timestamp': datetime.utcnow()
            })
        
        return signals
    
    def get_volume_profile(self):
        df = self.df.copy()
        
        if len(df) < 20:
            return None
        
        recent = df.tail(50)
        
        volume_avg = recent['volume'].mean()
        volume_current = recent.iloc[-1]['volume']
        volume_max = recent['volume'].max()
        
        return {
            'current_volume': round(volume_current, 2),
            'average_volume': round(volume_avg, 2),
            'max_volume': round(volume_max, 2),
            'volume_vs_avg': round((volume_current / volume_avg) * 100, 2),
            'volume_percentile': round((recent['volume'] <= volume_current).sum() / len(recent) * 100, 2)
        }


================================================================================
6. database.py - SQLALCHEMY MODELS AND AUTO-MIGRATION
================================================================================

import os
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, Text, JSON, inspect, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import streamlit as st

Base = declarative_base()

class Trade(Base):
    __tablename__ = 'trades'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False)
    market_type = Column(String(20), nullable=False)
    trade_type = Column(String(10), nullable=False)
    entry_price = Column(Float, nullable=False)
    exit_price = Column(Float)
    entry_time = Column(DateTime, default=datetime.utcnow)
    exit_time = Column(DateTime)
    quantity = Column(Float)
    profit_loss = Column(Float)
    profit_loss_percentage = Column(Float)
    outcome = Column(String(10))
    exit_type = Column(String(50))
    indicators_at_entry = Column(JSON)
    indicators_at_exit = Column(JSON)
    model_confidence = Column(Float)
    notes = Column(Text)

class ActivePosition(Base):
    __tablename__ = 'active_positions'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False)
    market_type = Column(String(20), nullable=False)
    trade_type = Column(String(10), nullable=False)
    entry_price = Column(Float, nullable=False)
    entry_time = Column(DateTime, default=datetime.utcnow)
    current_price = Column(Float)
    quantity = Column(Float)
    stop_loss = Column(Float)
    take_profit = Column(Float)
    timeframe = Column(String(10), default='1H')
    last_check_time = Column(DateTime)
    current_recommendation = Column(String(10))
    indicators_snapshot = Column(JSON)
    is_active = Column(Boolean, default=True)
    last_obv_slope = Column(Float)
    monitoring_alerts = Column(JSON)

class MarketData(Base):
    __tablename__ = 'market_data'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False)
    market_type = Column(String(20), nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow)
    open_price = Column(Float)
    high_price = Column(Float)
    low_price = Column(Float)
    close_price = Column(Float)
    volume = Column(Float)
    indicators = Column(JSON)

class ModelPerformance(Base):
    __tablename__ = 'model_performance'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    model_name = Column(String(50), nullable=False)
    version = Column(String(20))
    training_date = Column(DateTime, default=datetime.utcnow)
    accuracy = Column(Float)
    precision = Column(Float)
    recall = Column(Float)
    f1_score = Column(Float)
    total_trades = Column(Integer)
    winning_trades = Column(Integer)
    losing_trades = Column(Integer)
    win_rate = Column(Float)
    avg_profit = Column(Float)
    avg_loss = Column(Float)
    parameters = Column(JSON)
    is_active = Column(Boolean, default=True)

class WhaleActivity(Base):
    __tablename__ = 'whale_activity'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow)
    transaction_type = Column(String(10))
    volume = Column(Float)
    price = Column(Float)
    impact_score = Column(Float)
    notes = Column(Text)

class IndicatorPerformance(Base):
    __tablename__ = 'indicator_performance'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    indicator_name = Column(String(50), nullable=False, unique=True)
    correct_count = Column(Integer, default=0)
    wrong_count = Column(Integer, default=0)
    accuracy_rate = Column(Float, default=0.0)
    weight_multiplier = Column(Float, default=1.0)
    last_updated = Column(DateTime, default=datetime.utcnow)
    total_signals = Column(Integer, default=0)

class DivergenceEvent(Base):
    __tablename__ = 'divergence_events'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    trade_id = Column(Integer, nullable=True)
    symbol = Column(String(20), nullable=False)
    timeframe = Column(String(10), nullable=False)
    indicator = Column(String(20), nullable=False)
    divergence_type = Column(String(10), nullable=False)
    detected_at = Column(DateTime, default=datetime.utcnow)
    detection_price = Column(Float, nullable=False)
    resolved_at = Column(DateTime, nullable=True)
    resolution_price = Column(Float, nullable=True)
    resolution_candles = Column(Integer, nullable=True)
    resolution_outcome = Column(String(20), nullable=True)
    status = Column(String(20), default='active')

class DivergenceStats(Base):
    __tablename__ = 'divergence_stats'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    indicator = Column(String(20), nullable=False)
    timeframe = Column(String(10), nullable=False)
    divergence_type = Column(String(10), nullable=False)
    avg_resolution_candles = Column(Float, default=0.0)
    avg_resolution_minutes = Column(Float, default=0.0)
    median_resolution_candles = Column(Float, default=0.0)
    p90_resolution_candles = Column(Float, default=0.0)
    speed_class = Column(String(20), default='unknown')
    success_rate = Column(Float, default=0.0)
    sample_size = Column(Integer, default=0)
    last_updated = Column(DateTime, default=datetime.utcnow)

@st.cache_resource
def get_engine():
    database_url = os.getenv('DATABASE_URL')
    if not database_url:
        database_url = 'sqlite:///trading_platform.db'
        print("Warning: DATABASE_URL not set, using SQLite fallback")
    
    if database_url.startswith('sqlite'):
        engine = create_engine(database_url, connect_args={'check_same_thread': False})
    else:
        engine = create_engine(database_url, pool_pre_ping=True)
    
    return engine

def ensure_active_position_timeframe_column(engine):
    """Auto-add timeframe column to active_positions if missing (backward compatibility)"""
    try:
        inspector = inspect(engine)
        columns = [col['name'] for col in inspector.get_columns('active_positions')]
        
        if 'timeframe' not in columns:
            print("‚öôÔ∏è Auto-migration: Adding timeframe column to active_positions...")
            with engine.begin() as conn:
                conn.execute(text(
                    "ALTER TABLE active_positions ADD COLUMN timeframe VARCHAR(10) DEFAULT '1H'"
                ))
            print("‚úÖ Timeframe column added successfully!")
        
        if 'last_obv_slope' not in columns:
            print("‚öôÔ∏è Auto-migration: Adding last_obv_slope column to active_positions...")
            with engine.begin() as conn:
                conn.execute(text(
                    "ALTER TABLE active_positions ADD COLUMN last_obv_slope FLOAT"
                ))
            print("‚úÖ last_obv_slope column added successfully!")
        
        if 'monitoring_alerts' not in columns:
            print("‚öôÔ∏è Auto-migration: Adding monitoring_alerts column to active_positions...")
            with engine.begin() as conn:
                conn.execute(text(
                    "ALTER TABLE active_positions ADD COLUMN monitoring_alerts JSON"
                ))
            print("‚úÖ monitoring_alerts column added successfully!")
        
        if all(col in columns for col in ['timeframe', 'last_obv_slope', 'monitoring_alerts']):
            print("‚úÖ All columns exist - database is up to date")
    except Exception as e:
        print(f"Warning: Could not auto-migrate columns: {e}")

def init_db():
    try:
        engine = get_engine()
        Base.metadata.create_all(engine)
        ensure_active_position_timeframe_column(engine)
        return engine
    except Exception as e:
        print(f"Database initialization error: {e}")
        raise

def get_session():
    engine = get_engine()
    Session = sessionmaker(bind=engine)
    return Session()


================================================================================
7. scheduler.py - BACKGROUND 15-MIN MONITORING
================================================================================

import threading
import time
from datetime import datetime, timedelta
from position_monitor import PositionMonitor
from ml_engine import MLTradingEngine
from divergence_analytics import update_all_divergence_stats

class BackgroundScheduler:
    def __init__(self):
        self.monitor = PositionMonitor()
        self.ml_engine = MLTradingEngine()
        self.is_running = False
        self.thread = None
        self.last_analytics_run = None
        
    def start(self):
        if not self.is_running:
            self.is_running = True
            self.thread = threading.Thread(target=self._run, daemon=True)
            self.thread.start()
            print("Background scheduler started - Position monitoring every 15 minutes")
    
    def stop(self):
        self.is_running = False
        if self.thread:
            self.thread.join(timeout=5)
        print("Background scheduler stopped")
    
    def _run(self):
        while self.is_running:
            try:
                self._check_positions()
                self._run_analytics_if_needed()
                time.sleep(900)
            except Exception as e:
                print(f"Scheduler error: {e}")
                time.sleep(900)
    
    def _check_positions(self):
        try:
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Checking active positions...")
            results = self.monitor.check_active_positions()
            
            if results:
                for result in results:
                    if result['status'] == 'success':
                        print(f"  {result['symbol']}: {result['recommendation']} - {result['reason']}")
                    else:
                        print(f"  {result['symbol']}: Error - {result.get('message', 'Unknown error')}")
            else:
                print("  No active positions to monitor")
                
        except Exception as e:
            print(f"Error checking positions: {e}")
    
    def _run_analytics_if_needed(self):
        """Run divergence analytics once per day"""
        try:
            now = datetime.now()
            
            # Run if never run before or if it's been more than 24 hours
            if self.last_analytics_run is None or (now - self.last_analytics_run).total_seconds() > 86400:
                print(f"[{now.strftime('%Y-%m-%d %H:%M:%S')}] Running divergence analytics...")
                updated = update_all_divergence_stats()
                self.last_analytics_run = now
                if updated > 0:
                    print(f"  Updated {updated} divergence timing stats")
                else:
                    print(f"  No divergence stats updated (need more data)")
        except Exception as e:
            print(f"Error running divergence analytics: {e}")

_scheduler_instance = None

def get_scheduler():
    global _scheduler_instance
    if _scheduler_instance is None:
        _scheduler_instance = BackgroundScheduler()
    return _scheduler_instance


================================================================================
8. api_integrations.py - UNIFIED API CLIENT (TWELVE DATA + OKX)
================================================================================

import requests
import os
from datetime import datetime, timedelta
import pandas as pd
import time

class OKXClient:
    def __init__(self, api_key=None):
        self.base_url = "https://www.okx.com"
        self.api_key = api_key
        
    def get_market_data(self, symbol, interval='1H', limit=100):
        try:
            okx_symbol = symbol.replace('/', '-').replace('USD', 'USDT')
            
            endpoint = f"{self.base_url}/api/v5/market/candles"
            params = {
                'instId': okx_symbol,
                'bar': interval,
                'limit': limit
            }
            
            headers = {}
            if self.api_key:
                headers['OK-ACCESS-KEY'] = self.api_key
            
            response = requests.get(endpoint, params=params, headers=headers, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            if data['code'] == '0' and data['data']:
                df = pd.DataFrame(data['data'], columns=['timestamp', 'open', 'high', 'low', 'close', 'volume_coins', 'volCcy', 'volCcyQuote', 'confirm'])
                df['timestamp'] = pd.to_datetime(df['timestamp'].astype(int), unit='ms')
                df[['open', 'high', 'low', 'close', 'volCcyQuote']] = df[['open', 'high', 'low', 'close', 'volCcyQuote']].astype(float)
                df['volume'] = df['volCcyQuote']
                df = df.sort_values('timestamp')
                return df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]
            else:
                return None
                
        except Exception as e:
            print(f"OKX API Error: {e}")
            return None
    
    def get_orderbook(self, symbol, depth=20):
        try:
            endpoint = f"{self.base_url}/api/v5/market/books"
            params = {
                'instId': symbol,
                'sz': depth
            }
            
            response = requests.get(endpoint, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            if data['code'] == '0' and data['data']:
                return {
                    'bids': [[float(x[0]), float(x[1])] for x in data['data'][0]['bids']],
                    'asks': [[float(x[0]), float(x[1])] for x in data['data'][0]['asks']]
                }
            return None
            
        except Exception as e:
            print(f"OKX Orderbook Error: {e}")
            return None
    
    def get_ticker(self, symbol):
        try:
            okx_symbol = symbol.replace('/', '-').replace('USD', 'USDT')
            
            endpoint = f"{self.base_url}/api/v5/market/ticker"
            params = {'instId': okx_symbol}
            
            response = requests.get(endpoint, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            if data['code'] == '0' and data['data']:
                ticker = data['data'][0]
                return {
                    'symbol': symbol,
                    'last_price': float(ticker['last']),
                    'volume_24h': float(ticker['vol24h']),
                    'high_24h': float(ticker['high24h']),
                    'low_24h': float(ticker['low24h']),
                    'bid': float(ticker['bidPx']),
                    'ask': float(ticker['askPx'])
                }
            return None
            
        except Exception as e:
            print(f"OKX Ticker Error: {e}")
            return None

class TwelveDataClient:
    def __init__(self, api_key):
        self.base_url = "https://api.twelvedata.com"
        self.api_key = api_key
        
    def get_market_data(self, symbol, interval='1h', outputsize=100):
        try:
            endpoint = f"{self.base_url}/time_series"
            params = {
                'symbol': symbol,
                'interval': interval,
                'outputsize': outputsize,
                'apikey': self.api_key
            }
            
            print(f"Fetching {symbol} at {interval} interval...")
            response = requests.get(endpoint, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            print(f"API Response Status: {response.status_code}")
            print(f"API Response Keys: {list(data.keys())}")
            
            if 'values' in data and data['values']:
                df = pd.DataFrame(data['values'])
                df['datetime'] = pd.to_datetime(df['datetime'])
                
                rename_cols = {
                    'datetime': 'timestamp',
                    'open': 'open',
                    'high': 'high',
                    'low': 'low',
                    'close': 'close'
                }
                
                if 'volume' in df.columns:
                    rename_cols['volume'] = 'volume'
                
                df = df.rename(columns=rename_cols)
                
                df[['open', 'high', 'low', 'close']] = df[['open', 'high', 'low', 'close']].astype(float)
                
                if 'volume' in df.columns:
                    df['volume'] = df['volume'].astype(float)
                else:
                    df['volume'] = 0.0
                
                df = df.sort_values('timestamp')
                print(f"Successfully fetched {len(df)} candles")
                return df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]
            else:
                error_msg = data.get('message', data.get('status', 'Unknown error'))
                print(f"TwelveData Error: {error_msg}")
                print(f"Full response: {data}")
                return None
                
        except Exception as e:
            print(f"TwelveData API Error: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def get_quote(self, symbol):
        try:
            endpoint = f"{self.base_url}/quote"
            params = {
                'symbol': symbol,
                'apikey': self.api_key
            }
            
            response = requests.get(endpoint, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            if 'close' in data:
                return {
                    'symbol': symbol,
                    'last_price': float(data['close']),
                    'volume': float(data.get('volume', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'open': float(data.get('open', 0))
                }
            return None
            
        except Exception as e:
            print(f"TwelveData Quote Error: {e}")
            return None

def get_market_data_unified(symbol, market_type, interval='1H', limit=100):
    twelve_data_key = os.getenv('TWELVE_DATA_API_KEY')
    
    if twelve_data_key:
        twelve_client = TwelveDataClient(api_key=twelve_data_key)
        interval_map = {
            '5m': '5min',
            '15m': '15min',
            '30m': '30min',
            '1H': '1h',
            '4H': '4h',
            '1D': '1day',
            '1W': '1week'
        }
        td_interval = interval_map.get(interval, '1h')
        df = twelve_client.get_market_data(symbol, td_interval, limit)
        
        if df is not None and market_type == 'crypto' and 'volume' in df.columns:
            if df['volume'].sum() == 0:
                print(f"TwelveData returned {symbol} without volume data. Trying OKX for crypto volume...")
                okx_client = OKXClient()
                okx_df = okx_client.get_market_data(symbol, interval, limit)
                if okx_df is not None and okx_df['volume'].sum() > 0:
                    print(f"‚úì Using OKX data for {symbol} (has volume)")
                    return okx_df
                else:
                    print(f"‚ö† OKX also has no volume for {symbol}, using TwelveData anyway")
        
        return df
    
    if market_type == 'crypto':
        okx_client = OKXClient(api_key=os.getenv('OKX_API_KEY'))
        return okx_client.get_market_data(symbol, interval, limit)
    
    return None

def get_current_price(symbol, market_type):
    twelve_data_key = os.getenv('TWELVE_DATA_API_KEY')
    
    if twelve_data_key:
        twelve_client = TwelveDataClient(api_key=twelve_data_key)
        quote = twelve_client.get_quote(symbol)
        return quote['last_price'] if quote else None
    
    if market_type == 'crypto':
        okx_client = OKXClient(api_key=os.getenv('OKX_API_KEY'))
        ticker = okx_client.get_ticker(symbol)
        return ticker['last_price'] if ticker else None
    
    return None


================================================================================
9. divergence_logger.py - DIVERGENCE DETECTION LOGGING
================================================================================

"""
Divergence Logger - Tracks when divergences are detected
Surgical addition - does not modify existing trading logic
"""

from database import get_session, DivergenceEvent
from datetime import datetime

def log_divergence(symbol, timeframe, indicator, divergence_type, current_price):
    """
    Log a new divergence detection event
    
    Args:
        symbol: Trading pair (e.g., 'BTC/USD')
        timeframe: Chart timeframe (e.g., '1H')
        indicator: Indicator name (e.g., 'OBV', 'RSI')
        divergence_type: 'bullish' or 'bearish'
        current_price: Current market price
    
    Returns:
        DivergenceEvent ID or None if error
    """
    if divergence_type not in ['bullish', 'bearish']:
        return None
    
    try:
        session = get_session()
        
        # Check if active divergence already exists for this combo
        existing = session.query(DivergenceEvent).filter(
            DivergenceEvent.symbol == symbol,
            DivergenceEvent.timeframe == timeframe,
            DivergenceEvent.indicator == indicator,
            DivergenceEvent.divergence_type == divergence_type,
            DivergenceEvent.status == 'active'
        ).first()
        
        # If already logged and active, don't duplicate
        if existing:
            session.close()
            return existing.id
        
        # Create new divergence event
        event = DivergenceEvent(
            symbol=symbol,
            timeframe=timeframe,
            indicator=indicator,
            divergence_type=divergence_type,
            detection_price=current_price,
            detected_at=datetime.utcnow(),
            status='active'
        )
        
        session.add(event)
        session.commit()
        event_id = event.id
        session.close()
        
        return event_id
        
    except Exception as e:
        print(f"Error logging divergence: {e}")
        try:
            session.close()
        except:
            pass
        return None

def log_divergences_from_context(symbol, timeframe, trend_context, current_price):
    """
    Extract and log all divergences from trend_context
    
    Args:
        symbol: Trading pair
        timeframe: Chart timeframe
        trend_context: Dictionary with indicator trends
        current_price: Current market price
    
    Returns:
        List of logged event IDs
    """
    logged_events = []
    
    print(f"üîç Checking divergences for {symbol} {timeframe} (price: {current_price})")
    
    # List of indicators that track divergence
    indicators_with_divergence = ['RSI', 'Stochastic', 'MFI', 'OBV']
    
    for indicator in indicators_with_divergence:
        if indicator in trend_context:
            ctx = trend_context[indicator]
            divergence = ctx.get('divergence', 'none')
            
            print(f"  {indicator}: divergence={divergence}")
            
            if divergence in ['bullish', 'bearish']:
                print(f"  ‚úÖ Logging {divergence} divergence for {indicator}")
                event_id = log_divergence(
                    symbol=symbol,
                    timeframe=timeframe,
                    indicator=indicator,
                    divergence_type=divergence,
                    current_price=current_price
                )
                if event_id:
                    print(f"  üìä Logged divergence event ID: {event_id}")
                    logged_events.append(event_id)
                else:
                    print(f"  ‚ö†Ô∏è Failed to log divergence")
    
    if logged_events:
        print(f"‚úÖ Total divergences logged: {len(logged_events)}")
    else:
        print(f"  No divergences detected")
    
    return logged_events


================================================================================
10. divergence_resolver.py - AUTO-RESOLVE DIVERGENCES
================================================================================

"""
Divergence Resolver - Detects when divergences resolve or expire
Surgical addition - does not modify existing trading logic
"""

from database import get_session, DivergenceEvent
from datetime import datetime, timedelta

# Timeframe to minutes mapping
TIMEFRAME_MINUTES = {
    '5m': 5,
    '15m': 15,
    '30m': 30,
    '1H': 60,
    '4H': 240,
    '1D': 1440
}

def check_divergence_resolution(event, current_price, trend_context=None):
    """
    Check if a divergence event has resolved
    
    Resolution criteria:
    - Price moved 2%+ in predicted direction (bearish = down, bullish = up)
    - OR divergence disappeared from indicators (if trend_context provided)
    - OR max tracking window exceeded (20 candles)
    
    Args:
        event: DivergenceEvent object
        current_price: Current market price
        trend_context: Optional - current indicator trends
    
    Returns:
        (resolved, outcome) - (bool, str or None)
        outcome: 'success', 'failed', 'expired', or None
    """
    detection_price = event.detection_price
    price_change_pct = ((current_price - detection_price) / detection_price) * 100
    
    # Calculate time elapsed
    time_elapsed = datetime.utcnow() - event.detected_at
    timeframe_minutes = TIMEFRAME_MINUTES.get(event.timeframe, 60)
    candles_elapsed = time_elapsed.total_seconds() / 60 / timeframe_minutes
    
    # Check max tracking window (20 candles)
    if candles_elapsed > 20:
        return True, 'expired'
    
    # Check price movement threshold (2%)
    if event.divergence_type == 'bearish':
        # Bearish divergence expects price to fall
        if price_change_pct <= -2.0:
            return True, 'success'
        elif price_change_pct >= 3.0:
            # Price went up too much - divergence failed
            return True, 'failed'
    
    elif event.divergence_type == 'bullish':
        # Bullish divergence expects price to rise
        if price_change_pct >= 2.0:
            return True, 'success'
        elif price_change_pct <= -3.0:
            # Price went down too much - divergence failed
            return True, 'failed'
    
    # Check if divergence disappeared from indicators
    if trend_context and event.indicator in trend_context:
        current_divergence = trend_context[event.indicator].get('divergence', 'none')
        if current_divergence == 'none':
            # Divergence cleared - check if it succeeded
            if event.divergence_type == 'bearish' and price_change_pct < 0:
                return True, 'success'
            elif event.divergence_type == 'bullish' and price_change_pct > 0:
                return True, 'success'
            else:
                return True, 'failed'
    
    return False, None

def resolve_active_divergences(symbol, current_price, trend_context=None):
    """
    Check all active divergences for a symbol and resolve if needed
    
    Args:
        symbol: Trading pair
        current_price: Current market price
        trend_context: Optional - current indicator trends
    
    Returns:
        Number of divergences resolved
    """
    try:
        session = get_session()
        
        # Get all active divergences for this symbol
        active_events = session.query(DivergenceEvent).filter(
            DivergenceEvent.symbol == symbol,
            DivergenceEvent.status == 'active'
        ).all()
        
        resolved_count = 0
        
        for event in active_events:
            resolved, outcome = check_divergence_resolution(event, current_price, trend_context)
            
            if resolved:
                # Calculate resolution metrics
                time_elapsed = datetime.utcnow() - event.detected_at
                timeframe_minutes = TIMEFRAME_MINUTES.get(event.timeframe, 60)
                candles_elapsed = int(time_elapsed.total_seconds() / 60 / timeframe_minutes)
                
                # Update event
                event.resolved_at = datetime.utcnow()
                event.resolution_price = current_price
                event.resolution_candles = candles_elapsed
                event.resolution_outcome = outcome
                event.status = 'resolved'
                
                resolved_count += 1
        
        session.commit()
        session.close()
        
        return resolved_count
        
    except Exception as e:
        print(f"Error resolving divergences: {e}")
        try:
            session.close()
        except:
            pass
        return 0


================================================================================
11. divergence_analytics.py - TIMING STATISTICS CALCULATION
================================================================================

"""
Divergence Analytics - Calculates timing statistics from resolved divergences
Surgical addition - does not modify existing trading logic
"""

from database import get_session, DivergenceEvent, DivergenceStats
from datetime import datetime
import statistics

# Timeframe to minutes mapping
TIMEFRAME_MINUTES = {
    '5m': 5,
    '15m': 15,
    '30m': 30,
    '1H': 60,
    '4H': 240,
    '1D': 1440
}

def classify_divergence_speed(avg_candles):
    """
    Classify divergence speed based on candle count
    
    Speed classes (timeframe-relative):
    - FAST: <2 candles (too quick to profit)
    - ACTIONABLE: 2-6 candles (scalp window exists)
    - SLOW: >6 candles (takes too long)
    
    Args:
        avg_candles: Average resolution time in candles
    
    Returns:
        str: 'fast', 'actionable', or 'slow'
    """
    if avg_candles < 2:
        return 'fast'
    elif avg_candles <= 6:
        return 'actionable'
    else:
        return 'slow'

def calculate_divergence_stats(indicator, timeframe, divergence_type):
    """
    Calculate statistics for a specific divergence pattern
    
    Args:
        indicator: Indicator name (e.g., 'OBV')
        timeframe: Chart timeframe (e.g., '1H')
        divergence_type: 'bullish' or 'bearish'
    
    Returns:
        dict with stats or None if insufficient data
    """
    try:
        session = get_session()
        
        # Get all resolved events for this pattern
        events = session.query(DivergenceEvent).filter(
            DivergenceEvent.indicator == indicator,
            DivergenceEvent.timeframe == timeframe,
            DivergenceEvent.divergence_type == divergence_type,
            DivergenceEvent.status == 'resolved',
            DivergenceEvent.resolution_candles.isnot(None)
        ).all()
        
        session.close()
        
        # Need at least 5 samples for meaningful stats
        if len(events) < 5:
            return None
        
        # Extract resolution candles
        candles = [e.resolution_candles for e in events if e.resolution_candles > 0]
        
        if len(candles) < 5:
            return None
        
        # Calculate statistics
        avg_candles = statistics.mean(candles)
        median_candles = statistics.median(candles)
        
        # Calculate 90th percentile manually
        sorted_candles = sorted(candles)
        p90_index = int(len(sorted_candles) * 0.9)
        p90_candles = sorted_candles[min(p90_index, len(sorted_candles)-1)]
        
        # Convert to minutes
        timeframe_minutes = TIMEFRAME_MINUTES.get(timeframe, 60)
        avg_minutes = avg_candles * timeframe_minutes
        
        # Calculate success rate
        successes = len([e for e in events if e.resolution_outcome == 'success'])
        success_rate = (successes / len(events)) * 100
        
        # Classify speed
        speed_class = classify_divergence_speed(avg_candles)
        
        return {
            'avg_candles': round(avg_candles, 1),
            'avg_minutes': round(avg_minutes, 1),
            'median_candles': round(median_candles, 1),
            'p90_candles': round(p90_candles, 1),
            'speed_class': speed_class,
            'success_rate': round(success_rate, 1),
            'sample_size': len(events)
        }
        
    except Exception as e:
        print(f"Error calculating divergence stats: {e}")
        return None

def update_all_divergence_stats():
    """
    Update statistics for all divergence patterns
    Background job - runs nightly or on-demand
    
    Returns:
        Number of stat records updated
    """
    indicators = ['OBV', 'RSI', 'Stochastic', 'MFI']
    timeframes = ['5m', '15m', '30m', '1H', '4H', '1D']
    divergence_types = ['bullish', 'bearish']
    
    updated_count = 0
    
    try:
        session = get_session()
        
        for indicator in indicators:
            for timeframe in timeframes:
                for div_type in divergence_types:
                    
                    stats = calculate_divergence_stats(indicator, timeframe, div_type)
                    
                    if stats:
                        # Check if record exists
                        existing = session.query(DivergenceStats).filter(
                            DivergenceStats.indicator == indicator,
                            DivergenceStats.timeframe == timeframe,
                            DivergenceStats.divergence_type == div_type
                        ).first()
                        
                        if existing:
                            # Update existing
                            existing.avg_resolution_candles = stats['avg_candles']
                            existing.avg_resolution_minutes = stats['avg_minutes']
                            existing.median_resolution_candles = stats['median_candles']
                            existing.p90_resolution_candles = stats['p90_candles']
                            existing.speed_class = stats['speed_class']
                            existing.success_rate = stats['success_rate']
                            existing.sample_size = stats['sample_size']
                            existing.last_updated = datetime.utcnow()
                        else:
                            # Create new record
                            new_stat = DivergenceStats(
                                indicator=indicator,
                                timeframe=timeframe,
                                divergence_type=div_type,
                                avg_resolution_candles=stats['avg_candles'],
                                avg_resolution_minutes=stats['avg_minutes'],
                                median_resolution_candles=stats['median_candles'],
                                p90_resolution_candles=stats['p90_candles'],
                                speed_class=stats['speed_class'],
                                success_rate=stats['success_rate'],
                                sample_size=stats['sample_size']
                            )
                            session.add(new_stat)
                        
                        updated_count += 1
        
        session.commit()
        session.close()
        
        print(f"‚úÖ Updated {updated_count} divergence stat records")
        return updated_count
        
    except Exception as e:
        print(f"Error updating divergence stats: {e}")
        try:
            session.close()
        except:
            pass
        return 0

def get_divergence_timing_info(indicator, timeframe, divergence_type):
    """
    Get timing intelligence for a specific divergence pattern
    Used for displaying in UI
    
    Args:
        indicator: Indicator name
        timeframe: Chart timeframe
        divergence_type: 'bullish' or 'bearish'
    
    Returns:
        dict with timing info or None if no data
    """
    try:
        session = get_session()
        
        stat = session.query(DivergenceStats).filter(
            DivergenceStats.indicator == indicator,
            DivergenceStats.timeframe == timeframe,
            DivergenceStats.divergence_type == divergence_type
        ).first()
        
        session.close()
        
        if not stat or stat.sample_size < 5:
            return None
        
        return {
            'avg_candles': stat.avg_resolution_candles,
            'avg_hours': stat.avg_resolution_minutes / 60,
            'median_candles': stat.median_resolution_candles,
            'speed_class': stat.speed_class,
            'success_rate': stat.success_rate,
            'sample_size': stat.sample_size,
            'recommendation': get_speed_recommendation(stat.speed_class, divergence_type)
        }
        
    except Exception as e:
        print(f"Error getting divergence timing info: {e}")
        return None

def get_speed_recommendation(speed_class, divergence_type):
    """
    Get trading recommendation based on divergence speed
    
    Args:
        speed_class: 'fast', 'actionable', or 'slow'
        divergence_type: 'bullish' or 'bearish'
    
    Returns:
        str: Trading recommendation
    """
    if speed_class == 'fast':
        return "‚ö†Ô∏è FAST divergence - High risk! Consider waiting for reversal"
    elif speed_class == 'actionable':
        return "‚úÖ ACTIONABLE - Quick scalp possible with tight stops"
    elif speed_class == 'slow':
        return "‚è±Ô∏è SLOW divergence - Longer hold needed, harder to time exit"
    else:
        return "üìä Insufficient data for timing recommendation"


================================================================================
END OF CODE - TOTAL 11 MODULES
================================================================================
